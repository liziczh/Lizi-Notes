# 数据库

## 分页SQL

### Oracle分页语句

Oracle使用`ROWNUM`伪列实现分页：

```sql
select * 
from ( 
  select "temp".*, ROWNUM "rn" 
  from  <表/查询块> "temp" 
  where ROWNUM <= currengPage * pageSize ) 
where "rn" > (currentPage-1) * pageSize
```

> currentPage：当前页数。
> pageSize：每页显示的数据条数。

### MySql分页语句

MySql使用`LIMIT`关键字实现分页：

```sql
select *
from <表/查询块>
limit (currentPage-1)*pageSize, pageSize
```

> currentPage：当前页数。
> pageSize：每页显示的数据条数。

## 事务-TCL

**事务**：用于**保证数据完整性**。由一组DML语句组成，这组DML语句要么全部成功，要么全部失败。

### 事务特性：ACID

- **原子性（atomicity）**：一个事务是一个不可分割的工作单位，事务中的一组操作要么全做，要么全不做。
- **一致性（consistency）**：事务必须是使数据库从一个一致性状态变到另一个一致性状态。
- **隔离性（isolation）**：一个事务的执行不能被其他事务干扰。即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。
- **持久性（durability）**：指一个事务一旦提交，它对数据库中数据的改变就应该是永久性的。接下来的其他操作或故障不应该对其有任何影响。

### 事务并发不一致：

- **幻读**：事务T1读取一条指定条件的语句，返回结果集。此时事务T2插入一行新记录并commit，恰好满足T1的条件。然后T1使用相同的条件再次查询，结果集中可以看到T2插入的记录，这条新纪录就是幻想。（事务T1查询，并行事务T2插入/删除部分数据并提交，事务T1再次查询，数据发生改变）
- **不可重复读**：事务T1读取一行记录，紧接着事务T2修改了T1刚刚读取的记录并commit，然后T1再次查询，发现与第一次读取的记录不同，这称为不可重复读。 （事务T1读取一条记录，并行事务T2修改了该记录，事务T1再次查询，数据与第一次读的不同）
- **脏读**：一个事务读取了另一个未提交的并行事务写的数据。事务T1更新了一行记录，还未提交所做的修改，这个T2读取了更新后的数据，然后T1执行回滚操作，取消刚才的修改，所以T2所读取的行就无效，也就是脏数据。（事务T1更新但未提交，事务T2读取到更新后的数据，事务T1回滚，事务T2读取无效）
- **丢失更新**：当两个或多个事务选择同一数据，并且基于最初选定的值更新该数据时，会发生丢失更新问题。（事务T1读取数据，并行事务T2读取同一数据，事务T1更新并提交，事务T2更新并提交，事务T2覆盖事务T1提交结果）

### **四种隔离级别**：

- 读未提交：一个事务可以读取另一个未提交事务的数据。
- 读已提交：一个事务必须等另一个事务提交后才能读取数据。（Oracle，SQL Server默认）
- 可重复读：在开始读取数据（事务开启）时，不再允许修改操作。（MySQL默认）
- 串行化：事务串行化顺序执行。效率低下，一般不使用。

  > 读未提交 < 读已提交 < 可重复读 < 序列化

### 显式提交&隐式提交

- 显式提交：需要主动提交SQL语句对于数据库的修改，未提交之前可以rollback。如DML操作。
- 隐式提交：SQL语句执行结束自动提交，无法rollback。如DDL，DCL。



## SQL优化

1. 对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引
2. 应尽量避免在 where 子句中对字段进行 null 值判断，
3. 应尽量避免在 where 子句中使用!=或<>操作符
4. 应尽量避免在 where 子句中使用 or 来连接条件
5. 任何地方都不要使用 select * from t ，用具体的字段列表代替“*”
6. 避免频繁创建和删除临时表，以减少系统表资源的消耗
7. 尽量避免大事务操作，提高系统并发能力。
8. 尽量避免向客户端返回大数据量，若数据量过大，应该考虑相应需求是否合理