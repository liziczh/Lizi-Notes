### Java基础

Java跨平台原理：不同操作系统上有不同的JVM，可以将同一份.class文件执行为不同的机器码。

JVM作用：

① 执行代码：解释执行字节码文件

② 管理内存：将数据加载到内存中去

③ 垃圾回收机制：空闲时间不定时的动态回收无任何引用的对象所占用的空间。（只需new，不用delete）

编译阶段检查语法错误，运行阶段检查内存错误。

#### 数据类型

八大基本数据类型：byte，short，int，long，float，double，char，boolean。

类型提升：① byte，short，char之间不会相互转换，在计算时会自动转换为int类型进行计算。② Java运算时，自动提升至最大数据类型。③ 浮点型运算结果是double。

成员变量有默认值；局部变量无默认值，必须初始化。

#### 运算符

交换两个整数的值，不使用中间变量

（1） x=x+y; y=x-y; x=x-y;

（2）x=x*y; y=x/y; x=x/y;

（3）m=m^n; n=m^n; m=m^n;

使用最快速高效的方式，计算2e3。 位左移1<<3。

判断奇偶数：((num&1)==0) ? “偶数”! “奇数”。

#### 流程控制

switch后的表达式的类型：byte，short，int，char，JDK5引入 枚举；JDK7引入 String；

break：跳出当前循环，跳出一层循环。

continue：跳出本次循环，进行下次循环。

return：结束整个方法，必须是最后一句。

#### 方法

方法的重载（Overload）：方法名相同，参数列表不同（参数个数、类型、顺序不同），与返回值类型无关。

递归：自己调用自己，结束条件跳出递归。

#### 数组

数组初始化：

```java
int[] a = new int[8];
int[] a = {1,2,3,4,5}
// 数组长度：a.length
```

①值传递：基本类型数据传递（传递数据）

②引用传递：引用类型数据传递，参数指针传递；（传递地址）

引用关系：栈内存存放地址，引用堆内存内数据

引用变量值更改：return；

#### Object

equals()：比较两个对象的值是否相等。

hashCode()：返回该对象的哈希码值。

toString()：返回该对象的字符串表示。

finalize()：当垃圾回收器确定不存在对该对象的更多引用时（垃圾回收时），由对象的垃圾回收器调用此方法。

a.对象的finalize方法不一定会被调用，即使是进程退出前

b.发生gc()时一个对象的内存是否被释放取决于是否存在该对象的引用，该对象如果包含成员，那么对象成员遵循本条。

c.对象里包含的对象成员，按声明顺序进行释放。

#### String

String：不可变的字符序列，字符数组；字符串常量。

（1）所有字符串都是字符串常量，创建后值不可变。

（2）相同的字符串在字符串常量池中只有一份，常量池数据可共享。



StringBuffer&StringBuilder

- StringBuffer/StringBuilder：可变字符序列，通过某些方法调用可以改变字符序列的长度和内容。
- StringBuffer本质：构造一个其中不带字符的字符串缓冲区。
- StringBuffer()默认容量为 16 个字符。

String与StringBuffer/StringBuilder的区别：

- String是不可变的字符序列（资源利用率低）。
- StringBuffer/StringBuilder是可变的字符序列。

StringBuffer与StringBuilder的区别：

- StringBuffer线程安全但效率低。常用于数据共享，保证线程的安全性和一致性。
- StringBuilder线程不安全。常用于数据独享。

StringBuffer与StringBuilder的联系：StringBuilder是StringBuffer的兼容API。

#### 基本类型包装类

int与String相互转换：

int->String：

```java
// 1.Integer 静态方法
Integer.toString(int i);
// 2.String 静态方法
String.valueOf(int i);
```

String->int：

```java
// 1. Integer 静态方法
Integer.parseInt(String s);
// 2.构造方法初始化，再用intValue();
Integer i = new Integer(s);
i.intValue();
```

#### Date

Date->String：

```java
SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd hh:mm:ss");
// format：Date->String
String dateStr = format.format(new Date());
// parse：String->Date
Date date = format.parse("2019-06-01 12:00:00");
```



### 面向对象

面向对象的三大特性：封装、继承、多态。

- 封装：对外隐藏实现细节，提供公共访问方法。
- 继承：子类继承父类的非私有成员。
- 多态：父类的引用指向子类的对象。

类内执行顺序：静态（类加载执行）>非静态（实例化执行），父类>子类，代码块>构造器>成员方法。

#### 类与对象

new：栈内存存储地址，堆内存存储内容。

匿名对象：一次性，栈内没有引用地址。

构造方法：与类名相同，无返回值。创建对象时，由JVM自动调用。

this：代表本类当前对象。this()本类构造方法。

static：静态，类的所有对象共享。随类加载而加载。

final：最终修饰符，不可改变。

#### 继承

继承：子类继承父类的非私有成员。

继承都是单继承，不允许多继承，但可以多层继承。

super：代表父类当前对象。super()父类构造方法。

方法的重写（Override）：子类重写父类成员方法。访问修饰符不能比父类更严格。

静态方法是形式上的继承，本质上不是继承。不能被重写。

#### 多态

多态：父类的引用指向子类的对象。

多态访问类的成员：

- 成员变量：编译看左边，运行看左边。

- 成员方法：编译看左边，**运行看右边**。

- 静态变量/方法：编译看左边，运行看左边。

instanceof：判断该对象是否属于目标类；

```java
obj instanceof ClassA
```

#### 抽象类

抽象类（abstract）：用于被子类继承。不能被实例化，存在构造方法，不能被final修饰。

抽象方法（abstract）：用于被非抽象子类重写。只提供方法声明，不提供方法实现，不能被private、static、final修饰。

抽象方法只存在于抽象类/接口中，但抽象类可以没有抽象方法。

#### 接口

接口（interface）：定义一种规范与标准。

接口不能实例化，没有构造方法，可以多实现。

#### 内部类

内部类：定义再类内部，服务于外部类。

成员内部类实例化：外部类.内部类 对象 = new 外部类().new 内部类(); 

> 生成两个class文件：外部类.class，外部类$内部类.class。

方法内部类实例化：方法内实例化。

> 生成两个class文件：外部类.class，外部类$1内部类.class。

访问修饰符：

- public（跨包可访问）
- protected（子类可访问）
- default（包内可访问）
- private（类内可访问）



### 集合与泛型









### IO/NIO



### 多线程



### 反射



### JVM



### Servlet



### Cookie&Session



### JDBC



### AJAX



### SpringIOC



### SpringAOP



### SpringMVC



### MyBatis



### Spring Data JPA



### SpringBoot



### 了解SpringCloud



### MySQL



### 了解PL/SQL



### HTML+CSS



### JS



### Angular



### Redis



### Linux



### Git



### WebMagic



### 设计模式

单例模式：

```java
// 懒汉式
public class Singleton{
	// 定义静态成员实例
    private static Singleton s = null;
	// 私有化构造方法
    private Singleton(){}
	// 静态获取实例
    public static Singleton getInstance(){
        if(s == null){
            s = new Singleton();
        }
        return s;
    }
}
```

```java
// 饿汉式
public class Singleton{
    // 定义final静态成员实例
    private static final Singleton s = new Singleton();
    // 私有化构造方法
    private Singleton(){}
    // 公开静态获取实例方法
    public static Singleton getInstance(){
        return s;
    }
}
```



### 算法问题

二分查找：

```

```

冒泡排序：

```java
public void bubbleSort(int[] a){
    for(int i = a.length - 1; i > 0; i--){
        for(int j = 0; j < i; j++){
            if(a[j] > a[j+1]){
                temp = a[j];
               	a[j] = a[j+1];
                a[j+1] = a[j];
            }
        }
    }
}
```

选择排序：

```java
public void selectSort(int[] a){
    for(int i = 0; i > a.length; i++){
        for(int j = i+1; j > a.length - 1; j++){
            if(a[i] > a[j]){
                temp = a[i];
                a[i] = a[j];
                a[j] = a[i];
            }
        }
    }
}
```

快速排序：

```java
	/*
	 * 快速排序：交换排序 
	 * pivot：枢轴指针; pivotkey：枢轴值，
	 * low：低指针， high：高指针，
	 * partition(数组名称,起始位下标,末尾位下标); 
	 * qSort(数组名称,起始位下标,末尾位下标);
	 */
	// 分区函数，返回枢轴指针
	public int partition(int[] arr, int low, int high) {
		int pivotkey = arr[low];// 设第一个元素为枢轴值
		while (low < high) {
			while (low < high && arr[high] >= pivotkey) {
				high--;
			} // while
			arr[low] = arr[high];
			while (low < high && arr[low] <= pivotkey) {
				low++;
			} // while
			arr[high] = arr[low];
		} // while
		arr[low] = pivotkey;// 将枢轴值 给到 可覆盖区
		return low;// 返回枢轴指针
	}// partition

	// 分区递归
	public void qSort(int[] arr, int low, int high) {
		if (low < high) {
			int pivot = partition(arr, low, high);// 枢轴指针
			qSort(arr, low, pivot - 1);// 前半部分
			qSort(arr, pivot + 1, high);// 后半部分
		}
	}// qSort

	public void quickSort(int[] arr) {
		qSort(arr, 0, arr.length - 1);
	}// quickSort
```

