### Java基础

Java跨平台原理：不同操作系统上有不同的JVM，可以将同一份.class文件执行为不同的机器码。

JVM作用：

① 执行代码：解释执行字节码文件

② 管理内存：将数据加载到内存中去

③ 垃圾回收机制：空闲时间不定时的动态回收无任何引用的对象所占用的空间。（只需new，不用delete）

编译阶段检查语法错误，运行阶段检查内存错误。

#### 数据类型

八大基本数据类型：byte，short，int，long，float，double，char，boolean。

类型提升：① byte，short，char之间不会相互转换，在计算时会自动转换为int类型进行计算。② Java运算时，自动提升至最大数据类型。③ 浮点型运算结果是double。

成员变量有默认值；局部变量无默认值，必须初始化。

#### 运算符

交换两个整数的值，不使用中间变量

（1） x=x+y; y=x-y; x=x-y;

（2）x=x*y; y=x/y; x=x/y;

（3）m=m^n; n=m^n; m=m^n;

使用最快速高效的方式，计算2e3。 位左移1<<3。

判断奇偶数：((num&1)==0) ? “偶数”! “奇数”。

#### 流程控制

switch后的表达式的类型：byte，short，int，char，JDK5引入 枚举；JDK7引入 String；

break：跳出当前循环，跳出一层循环。

continue：跳出本次循环，进行下次循环。

return：结束整个方法，必须是最后一句。

#### 方法

方法的重载（Overload）：方法名相同，参数列表不同（参数个数、类型、顺序不同），与返回值类型无关。

递归：自己调用自己，结束条件跳出递归。

#### 数组

数组初始化：

```java
int[] a = new int[8];
int[] a = {1,2,3,4,5}
// 数组长度：a.length
```

①值传递：基本类型数据传递（传递数据）

②引用传递：引用类型数据传递，参数指针传递；（传递地址）

引用关系：栈内存存放地址，引用堆内存内数据

引用变量值更改：return；

#### Object

equals()：比较两个对象的值是否相等。

hashCode()：返回该对象的哈希码值。

toString()：返回该对象的字符串表示。

**finalize()**：当垃圾回收器确定不存在对该对象的更多引用时（垃圾回收时），由对象的垃圾回收器调用此方法。

> a.对象的finalize方法不一定会被调用，即使是进程退出前
>
> b.发生gc()时一个对象的内存是否被释放取决于是否存在该对象的引用，该对象如果包含成员，那么对象成员遵循本条。
>
> c.对象里包含的对象成员，按声明顺序进行释放。

**Java Object 重写 equals() 方法的同时为什么要重写 hashCode()？** 

因为 equals() 与 hashCode() 必须保持一致；

- 当 obj1.equals(obj2) 为 true，obj1.hashCode() 必须等于 obj2.hashCode()；
- 当obj1.hashCode() == obj2.hashCode()为false时，obj1.equals(obj2)必须为false；

#### String

String：不可变的字符序列，字符数组；字符串常量。

（1）所有字符串都是字符串常量，创建后值不可变。

（2）相同的字符串在字符串常量池中只有一份，常量池数据可共享。



StringBuffer&StringBuilder

- StringBuffer/StringBuilder：可变字符序列，通过某些方法调用可以改变字符序列的长度和内容。
- StringBuffer本质：构造一个其中不带字符的字符串缓冲区。
- StringBuffer()默认容量为 16 个字符。

String与StringBuffer/StringBuilder的区别：

- String是不可变的字符序列（资源利用率低）。
- StringBuffer/StringBuilder是可变的字符序列。

StringBuffer与StringBuilder的区别：

- StringBuffer线程安全但效率低。常用于数据共享，保证线程的安全性和一致性。
- StringBuilder线程不安全。常用于数据独享。

StringBuffer与StringBuilder的联系：StringBuilder是StringBuffer的兼容API。

#### 基本类型包装类

int与String相互转换：

int->String：

```java
// 1.Integer 静态方法
Integer.toString(int i);
// 2.String 静态方法
String.valueOf(int i);
```

String->int：

```java
// 1. Integer 静态方法
Integer.parseInt(String s);
// 2.构造方法初始化，再用intValue();
Integer i = new Integer(s);
i.intValue();
```

#### Date

Date->String：

```java
SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd hh:mm:ss");
// format：Date->String
String dateStr = format.format(new Date());
// parse：String->Date
Date date = format.parse("2019-06-01 12:00:00");
```



### 面向对象

面向对象的三大特性：封装、继承、多态。

- 封装：对外隐藏实现细节，提供公共访问方法。
- 继承：子类继承父类的非私有成员。
- 多态：父类的引用指向子类的对象。

类内执行顺序：静态（类加载执行）>非静态（实例化执行），父类>子类，代码块>构造器>成员方法。

#### 类与对象

new：栈内存存储地址，堆内存存储内容。

匿名对象：一次性，栈内没有引用地址。

构造方法：与类名相同，无返回值。创建对象时，由JVM自动调用。

this：代表本类当前对象。this()本类构造方法。

static：静态，类的所有对象共享。随类加载而加载。

final：最终修饰符，不可改变。

#### 继承

继承：子类继承父类的非私有成员。

继承都是单继承，不允许多继承，但可以多层继承。

super：代表父类当前对象。super()父类构造方法。

方法的重写（Override）：子类重写父类成员方法。访问修饰符不能比父类更严格。

静态方法是形式上的继承，本质上不是继承。不能被重写。

#### 多态

多态：父类的引用指向子类的对象。

多态访问类的成员：

- 成员变量：编译看左边，运行看左边。

- 成员方法：编译看左边，**运行看右边**。

- 静态变量/方法：编译看左边，运行看左边。

instanceof：判断该对象是否属于目标类；

```java
obj instanceof ClassA
```

#### 抽象类

抽象类（abstract）：用于被子类继承。不能被实例化，存在构造方法，不能被final修饰。

抽象方法（abstract）：用于被非抽象子类重写。只提供方法声明，不提供方法实现，不能被private、static、final修饰。

抽象方法只存在于抽象类/接口中，但抽象类可以没有抽象方法。

#### 接口

接口（interface）：定义一种规范与标准。

接口不能实例化，没有构造方法，可以多实现。

#### 内部类

内部类：定义再类内部，服务于外部类。

成员内部类实例化：外部类.内部类 对象 = new 外部类().new 内部类(); 

> 生成两个class文件：外部类.class，外部类$内部类.class。

方法内部类实例化：方法内实例化。

> 生成两个class文件：外部类.class，外部类$1内部类.class。

访问修饰符：

- public（跨包可访问）
- protected（子类可访问）
- default（包内可访问）
- private（类内可访问）

### 异常

```java
try{
	可能发生异常的代码；
}catch( 异常类型 相应类型变量 ){
	异常处理；（异常发生时执行）
}finally{
	必然执行；（无论异常是否发生，必然执行）
}
```

try块中有return语句，finally语句还会执行吗？在什么时候执行？

- 异常未发生，finally一定会执行；finally先于return执行；

- 异常发生，finally一定会执行，return不执行；

- 异常发生后，try块内异常之后的语句不执行；

### 集合

Collection：List，Set。

- List（列表，**有序可重复**）：ArrayList，Vector，LinkedList。

- Set（数学集合，**无序不重复**）：HashSet，TreeSet。

Map（键值对，**无序双列**）：HashTable，HashMap，TreeMap。

#### List

List - 列表【有序可重复】；有序指插入顺序。

**ArrayList**：基于**可变数组**实现的List；

- 允许多个null值，线程不同步，查询效率高。

**Vector**：基于**可变数组**实现的**线程安全**的List（已过时）。

- 允许多个null值，线程同步，查询效率高。

**LinkedList**：基于**双向链表**实现的List。

- 允许多个null值，线程不同步，插入删除效率高。

#### Set

Set - 数学集合【无序不重复】；满足确定性、互异性、无序性。

**HashSet**：基于HashMap（哈希表）实现，元素为HashMap中的Key。

- 允许一个null值，线程不同步，通过equals()和hashCode()判断重复元素。

**Java Object 重写 equals() 方法的同时为什么要重写 hashCode()？** 

因为 equals() 与 hashCode() 必须保持一致；

- 当 obj1.equals(obj2) 为 true，obj1.hashCode() 必须等于 obj2.hashCode()；
- 当obj1.hashCode() == obj2.hashCode()为false时，obj1.equals(obj2)必须为false；

**TreeSet**：基于TreeMap（二叉树）实现，元素为TreeMap中的key；主要用来**元素排序**。

- 允许一个null值，线程不同步，通过集合元素类实现Comparable接口，重写compareTo()方法来排序。

**自然排序（Comparable）**

自然排序：通过集合元素类实现 Comparable 接口，重写 compareTo() 方法排序。

comparaTo() 返回值：

TreeSet 底层为一个二叉树

- `return 0;` 表示集合中只存一个元素。元素值每次比较，都认为是相同的元素，这时就不再向TreeSet中插入除第一个外的新元素。
- `return 1;` 表示集合正序排列。元素值每次比较，都认为新插入的元素比上一个元素大，于是二叉树存储时，会存在根的右侧，读取时就是正序排列的。
- `return -1;` 表示集合倒序排列。元素值每次比较，都认为新插入的元素比上一个元素小，于是二叉树存储时，会存在根的左侧，读取时就是倒序序排列的。

**比较器排序 `Comparator<T>`** 

创建 TreeSet 类时制定一个 Comparator 接口，重写 compara() 方法制定排序规则。

**Iterator 迭代器**：hasNext() - 判断是否存在下一个元素；next() - 获取下一个元素。

#### Map

Map - 键值对集合【无序双列】。

- key不允许重复。

**HashTable**：**哈希表**，线程同步（使用synchronized实现同步）。

- 不允许null键null值

**HashMap**：基于**Hash桶数组**实现Map；

- 支持null键null值。

- 生成相同hashCode的不同key存储在同一个bucket下，null健存储在0 bucket下。

**HashTable与HashMap的区别**：

① 关于null：

- HashTable不支持 null-key 和 null-value。HashTable 遇到 null，抛出 NullPointerException。
- HashMap支持 null-key 和 null-value。HashMap 对 null 做了特殊处理，将 null 的 hashCode 值定为了 0，从而将其存放在哈希表的第0个 bucket 中。

② 扩容方式：

- HashTable 默认初始化容量大小为11，之后每次扩充为原来的2n+1。

- HashMap默认初始化容量大小为16，之后每次扩充为原来的2倍。

  > 在取模计算时，如果模数是2的幂，那么我们可以直接使用位运算来得到结果，效率要大大高于做除法。所以从hash计算的效率上，又是HashMap更胜一筹。

③ 线程安全：

- HashTable 线程安全（同步）；

- HashMap 线程不安全（不同步）；

  > HashTable已经被淘汰了，如果你不需要线程安全，使用HashMap；如果你需要线程安全，使用ConcurrentHashMap；

④ 数据结构：

- HashTable 数组+链表
- HashMap 数组+链表/红黑树（JDK1.8）

**ConcurrentHashMap和Hashtable的区别**：

- HashTable 采用 synchronized 实现同步，单锁锁定整个集合，迭代时其他线程必须等待其迭代完成才能访问 map，所以当 Hashtable 的大小增加到一定的时候，性能会急剧下降。
- ConcurrentHashMap 引入了分割（segmentation），仅锁定 map 的某个部分，更适用于高并发。

**fail-fast 与 fail-safe 机制有什么区别**：

- fail-fast（快速失败）：快速失败机制在遍历一个集合时，如果集合内容被修改，会抛出ConcurrentModificationException异常。 
- fail-safe（安全失败）：安全失败机制对集合的任何修改都会在一个复制的集合上进行，因此不会抛出异常。

**TreeMap**：基于**红黑树**实现的Map。

- 不允许null键，允许null值。

**红黑树**：自平衡二叉查找树。

- 只有红、黑结点。
- 根是黑结点。
- 叶结点尾端的NIL结点是黑的。
- 红结点的子结点必须都是黑的。
- 对于任意结点，其到叶结点尾端NIL结点的每条路径上都包含相同数目的黑结点。

#### 泛型

**泛型**：为解决集合元素取出时，自动转化成Object类型的问题，在不确定集合类型时，进行集合元素类型的参数化。

泛型擦除：泛型只在编译阶段有效，运行阶段就不存在了；

泛型通配符：

- `<? extends T>` 下限，只能使用T和T的子类；

- `<? super T>` 上限，只能使用T和T的父类；

- `<?>` 未知类型，默认Object类型；

可变参数：定义方法时不确定传入参数的个数，可变参数要位于参数列表的末尾。

```java
(int ... vals);
```



### IO/NIO

#### BIO

IO - 面向**流**的阻塞式IO。

字节流：InputStream，OutputStream。读写二进制数据，图片视频等。

字符流：Reader，Writer。读写纯文本档案。

```java
/* 文件复制
 * int read(byte[] buffer); 读入字节数组，返回读取字节数；
 * void write(byte[] b,int off,int len); 写入数组的某一部分
 */ 
public void copy(File src, File desc) throws IOException {
    InputStream  in = new FileInputStream(src);
    OutputStream out = new FileOutputStream(desc)；
	int len = 0;
	byte[] buffer = new byte[1024];
	while((len = in.read(buffer)) != -1){
		out.write(buffer, 0, len);
	}
    in.close();
    out.close();
}
```

#### NIO

NIO - 面向**缓冲区**，基于**通道**和**选择器**的**同步非阻塞**式IO（线程同步）。

- Buffer存储数据，读写都是操作缓冲区，filp()进行读写模式切换。

- Channel数据载体，多路复用，通过Channel向Buffer读写数据。

- Selector注册通道（同步），允许单线程处理多个Channel，由selector阻塞式地轮询IO事件的就绪。

```java
// 分散读取，聚集写入
while((inChannel.read(bufs)) != -1) {
	for(ByteBuffer b : bufs) {
		b.flip();
		outChannel.write(b);
		b.clear();
	}
}
```

### 多线程

**并发与并行的区别**：

- 并发：多个任务轮询交替执行；

- 并行：多个任务同时执行；

**进程与线程的区别**：

- 进程是资源（CPU、内存等）分配的基本单位，它是程序执行时的一个实例。程序运行时系统就会创建一个进程，并为它分配资源，然后把该进程放入进程就绪队列，进程调度器选中它的时候就会为它分配CPU时间，程序开始真正运行。

- 线程是程序执行时的最小单位，它是进程的一个执行流，是CPU调度和分派的基本单位，一个进程可以由很多个线程组成，线程间共享进程的所有资源，每个线程有自己的堆栈和局部变量。线程由CPU独立调度执行，在多CPU环境下就允许多个线程同时运行。同样多线程也可以实现并发操作，每个请求分配一个线程来处理。

**用户线程与守护线程**：

- 用户线程：前台线程，
- 守护线程：后台线程，守护线程作用是为其他前台线程的运行提供便利服务，而且仅在普通、非守护线程仍然运行时才需要。如果没有用户线程，守护线程也就没有存在下去的意义了。

**创建线程**：

- 继承Thread类，重写run()方法。
- 实现Runnable接口，重写run()方法，本质是 `Thread(Runnable target)` 。

**线程的生命周期**：

- **新建状态（New）**：创建线程后，进入新建状态。
- **就绪状态（Runnable）**：线程调用 start() 方法进入就绪状态，随时准备获取CPU使用权。
- **运行状态（Running）**：CPU调度该线程，线程获取到CPU使用权，进入运行状态。
- **阻塞状态（Blocked）**：① wait()，进入等待阻塞，② 获取synchronized同步锁时，锁对象被其他线程占用，进入同步阻塞状态，③ sleep()，④ join()，⑤阻塞式 IO 操作；
- **死亡状态（Dead）**：① 线程执行完毕，② 线程异常退出，③ stop()；

**阻塞&阻塞解除**：

- wait() 进入阻塞，notify() 与 notifyAll() 解除阻塞。
- 等待同步锁进入阻塞，获得同步锁解除阻塞。
- 阻塞式IO操作进入阻塞，阻塞式IO结束解除阻塞。
- sleep() 进入阻塞，睡眠时间到解除阻塞。
- join() 进入阻塞。

**线程池**：

```java
public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue, RejectedExecutionHandler handler) 
/*
 * corePoolSize：核心线程数
 * maximumPoolSize：线程池最大线程数
 * keepAliveTime：空闲线程存活时间，线程数>核心线程数时激活。
 * unit：keepAliveTime的时间单位。
 * workQueue：阻塞队列。
 * handler：超出线程范围和队列容量的任务的处理程序
 */
```

首先判断核心线程（corePool）是否全部使用。

若核心线程全部使用，将任务添加到阻塞队列（workQueue）中。

若阻塞队列已满，比较线程数是否已超过maximumPoolSize。

若未超过最大线程数，则创建新线程去执行任务。

当线程池中的线程数>corePoolSize，且存在空闲线程时，回收空闲线程，空闲线程存活时间为keepAliveTime。

**线程同步**：

线程同步：保护共享数据，防止数据不一致；

1.同步方法：synchronized 修饰的方法。

2.同步代码块：

```java
synchronized(obj){}
```

### **线程通信**

**Object类的监视器方法（monitor）**

等待/通知机制

Object监视器方法：wait()、notify()、notifyAll()；

wait()：使线程进入等待状态，如果没有线程来唤醒，则一直处于等待状态；

wait(long timeout)：使线程进入等待状态； 

notify()：唤醒当前处于等待状态的随机一个线程；

notifyAll()：唤醒当前处于等待状态的所有线程；

锁对象执行wait()；和notify()；



### 反射

反射：在程序运行时，通过类的Class对象（类名、对象获取）去动态获取类构造器、属性。

获取类的Class对象

- 对象.getClass()；

- 类.class；

- Class.forName(String className)；全类名；



### JVM

栈：主要用来执行java程序，线程私有。

本地方法栈：为执行本地方法分配内存空间；

程序计数器：标记程序执行的跳转和调用；实现选择/循环。

堆内存：新生代（Eden，from，to），老年代，永久代（不属于堆区）；

Eden-->Survive0（from）-->Survive1（to）-->老年代；

### HTTP

HTTP超文本传输协议，无连接，无状态。请求协议+响应协议。请求响应模式。

GET（查）、POST（增）、PUT（改）、DELETE（删）。

- **GET** - 从指定的资源请求数据。一般用于**查询资源信息**。
- **POST** - 向指定的资源提交要被处理的数据。一般用于**更新资源信息**。 

| 操作方式 | GET                     | POST     |
| -------- | ----------------------- | -------- |
| 数据位置 | HTTP包头                | HTTP正文 |
| 数据加密 | 明文（数据暴露在URL中） | 可明可密 |
| 数据安全 | 不安全                  | 安全     |
| 数据长度 | 1KB以下                 | 无限制   |
| 应用场景 | 查询数据                | 修改数据 |

### Servlet

Servlet处理请求：接受请求数据，处理请求，完成响应。

ServletConfig：Servlet独享。

ServletContext：Web应用共享。

**Servlet生命周期**：

- Servlet 通过调用 **init ()** 方法进行初始化。
- Servlet 调用 **service()** 方法来处理客户端的请求。
- Servlet 通过调用 **destroy()** 方法终止（结束）。
- 最后，Servlet 是由 JVM 的垃圾回收器进行垃圾回收的。



### Cookie&Session

由于 HTTP 是一种**无状态**协议，浏览器每一次请求都是独立的，无法维持客户端与Web 服务器之间的会话状态，所以引入**会话跟踪**技术，即 **Cookie** 和 **Session** 机制。

Web 应用中的**会话**指一个客户端浏览器与 Web 服务器之间连续发生的一系列请求与响应过程。**会话状态**指 Web 服务器与浏览器在会话过程中产生的状态信息。**SessionID** 用于唯一地标识一个会话的请求信息。

#### Cookie机制

Cookie 机制采用客户端保持HTTP状态信息。

Cookie 机制：①服务器脚本向客户端浏览器发送一组 Cookie；②客户端浏览器将这些信息存储在本地计算机上；③当下一次浏览器向 Web 服务器发送请求时，浏览器会将这些 Cookie 信息发送到服务器，服务器通过这些 Cookie 信息识别用户。

#### Session机制

Session 机制采用在服务器端记录客户端会话状态信息。

Session 机制：①在客户端浏览器第一次访问服务器时，Web 服务器为客户端浏览器创建一个会话对象（session 对象），并生成一个对应的 SessionID，服务器把客户端会话状态记录在用户独享的 session 对象中。②在客户端再次访问时，服务器根据客户端携带的 SessionID 从 session 域中查找用户的信息。

### JDBC

JDBC：

① 加载和注册驱动：

② 获取数据库连接

③ 执行sql语句

④ 处理结果集

⑤ 释放资源

```java
public class JDBCDemo {
	public static void main(String[] args) {
		// 声明变量
		Connection conn = null;
		Statement stat = null;
		ResultSet res = null;
		List<User> userList = new ArrayList<>();
        
		try {
			// 1.加载和注册驱动
			String driverClassName = "com.mysql.jdbc.Driver";
			Class.forName(driverClassName);
			// 2.获取数据库连接
			String url = "jdbc:mysql:///lizi";
			String ur = "root";
			String pwd = "root";
			conn = DriverManager.getConnection(url, ur, pwd);
			// 3.执行sql查询语句
			stat = conn.createStatement();
			String sql = " select * from user ";
			res = stat.executeQuery(sql);
			// 4.迭代处理结果集
			while(res.next()) {
				User user = new User();
				user.setId(res.getInt("id"));
				user.setUsername(res.getString("username"));
				user.setPassword(res.getString("password"));
				userList.add(user);
			}
		} catch (ClassNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (SQLException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}finally {
			// 5.关闭连接，释放资源
			try {
				// 释放结果集
				res.close();
			} catch (SQLException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}finally {
				try {
					// 释放statement对象
					stat.close();
				} catch (SQLException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}finally {
					try {
						// 关闭数据库连接
						conn.close();
					} catch (SQLException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
			}
		}
	}
}
```

**数据库连接池**：负责分配、管理和释放数据库连接。采用数据库连接池复用连接，减少频繁打开关闭数据库连接的资源开销，提高性能。

### AJAX

AJAX：异步请求，局部刷新。

**AJAX底层**：

（1）创建一个 XMLHttpRequest 对象

（2）`open(String method, String url, boolean async)` - 打开与服务器的连接。

> - method：请求类型，GET / POST；
> - url：文件路径；
> - async：true (异步)，false (同步)，默认为 true；

（3）`send(String data)`  - 将请求的数据发送到服务器。

> - GET请求：`send()`，数据可直接通过 open() 中的URL地址传送。
> - POST请求：`send("key=value&key=value")`，数据以键值对形式发送。
>
> 如果是 POST 请求，则需要在 open() 打开链接后，设置请求头内容类型：
>
> ```js
> xhr.setRequestHeader("Content-Type","application/x-www-form-urlencoded");
> ```

```javascript
function createXMLHttpRequest() {
  var xhr;
  if (window.XMLHttpRequest) {
    //  IE7+, Firefox, Chrome, Opera, Safari 浏览器执行代码
    xhr=new XMLHttpRequest();
  } else {
    // IE6, IE5 浏览器执行代码
    xhr=new ActiveXObject("Microsoft.XMLHTTP");
  }
}
window.onload = function () {
  // 1. 创建一个 XMLHttpRequest 对象
  var xhr = createXMLHttpRequest();
  // 2. 打开与服务器的连接
  xhr.open("POST","/index.jsp",true);
  // -  POST 请求需要设置请求头
  xhr.setRequestHeader("Content-Type","application/x-www-form-urlencoded")
  // 3. 发送数据
  xhr.send("username=scott&password=tiger");
  // 4. 当响应完成&页面正常的情况下，接受响应数据，写入myDiv中。
  xhr.onreadystatechange = function(){
    if (xmlhttp.readyState == 4 && xmlhttp.status == 200){
      document.getElementById("myDiv").innerHTML = xhr.responseText;
    }
  }
}
```

**AJAX使用**：

```javascript
$.ajax({
    type: "GET",
    url: "test.json",
    data: {username:"scott", content:"tiger"},
    dataType: "json",
    success: function(data){
    	// doSomething...
    }
});
```

**跨域CORS**

```java
response.setHeader("Access-Control-Allow-Origin","*");
```

> 支持 GET 和 POST 请求

### SpringIOC

IOC（控制反转）：预初始化所有bean，放入IOC容器中。

DI（依赖注入）：调用setter()方法/构造方法进行注入。

**基于Java反射机制实现**：

解析XML文件，获取Bean的class属性，得到Bean的全类名，利用反射机制获取Bean的Class对象，实例化Bean，放入Spring容器中。



### SpringAOP

AOP（面向切面编程）：将交叉业务逻辑织入主业务逻辑中。底层采用动态代理模式实现。



### SpringMVC

![springmvc](F:\lizi-cloud\lizi-doc\springmvc.jpg)

（1）用户发送请求到DispatcherServlet。

（2）DispatcherServlet收到请求调用HandlerMapping处理器映射器，HandlerMapping根据url找到相应的处理器，返回处理器对象Handler和处理器拦截器链HandlerExecutionChain。

（3）DispatcherServlet通过HandlerAdapter适配器调用具体Handler，返回ModelAndView。

（4）DispatcherServlet将ModelAndView传给ViewReslover视图解析器。

（5）ViewReslover解析后返回具体的View。

（6）DispatcherServlet对View进行视图渲染（数据填充）。

（7）DispatcherServlet将视图响应给用户。



### MyBatis





### Spring Data JPA





### SpringBoot





### 了解SpringCloud





### SQL语句

```sql
SELECT [DISTINCT] <目标列表达式> [AS] <别名>
FROM <表/视图> [AS] <别名>
[WHERE <查询条件>]
[GROUP BY <分组列> [HAVING <分组条件>]]
[ORDER BY <排序列> [ASC|DESC]];
```

WHERE 查询条件：

```sql
<列名> [NOT] BETWEEN <下限> AND <上限>
<列名> [NOT] IN （值1, 值2...）
<列名> [NOT] LIKE '<匹配模式>'  // % 替代一个或多个字符，_ 替代一个字符。
```

**WHERE 子句与 HAVING 子句区别**：
①WHERE 子句作用于基本表/视图，不能使用聚集函数。
②HAVING 子句作用于组。

#### 连接查询

交叉连接：笛卡儿积。

```mysql
SELECT * FROM t1, t2;
SELECT * FROM t1 CROSS JOIN t2;
```

自然连接：去除重复列，消除了笛卡儿积。

```mysql
SELECT * FROM t1 NATURAL JOIN t2;
```

内连接：查询与连接条件匹配的所有行，但不去除重复属性列。

```mysql
SELECT * FROM t1, t2 WHERE t1.a = t2.a;
SELECT * FROM t1 [INNER] JOIN t2 ON t1.a = t2.a;
```

外连接：主表内容全部显示。从表未匹配到的，用NULL填充。

```mysql
SELECT * FROM t1 LEFT JOIN t2 ON t1.a = t2.a;
SELECT * FROM t1 RIGHT JOIN t2 ON t1.a = t2.a;
SELECT * FROM t1 FULL JOIN t2 ON t1.a = t2.a;
```

### 事务-TCL

**事务**：用于**保证数据完整性**。由一组DML语句组成，这组DML语句要么全部成功，要么全部失败。

**事务特性：ACID**：

- **原子性（atomicity）**：一个事务是一个不可分割的工作单位，事务中的一组操作要么全做，要么全不做。
- **一致性（consistency）**：事务必须是使数据库从一个一致性状态变到另一个一致性状态。
- **隔离性（isolation）**：一个事务的执行不能被其他事务干扰。即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。
- **持久性（durability）**：指一个事务一旦提交，它对数据库中数据的改变就应该是永久性的。接下来的其他操作或故障不应该对其有任何影响。

**事务并发不一致**：

- **幻读**：事务T1读取一条指定条件的语句，返回结果集。此时事务T2插入一行新记录并commit，恰好满足T1的条件。然后T1使用相同的条件再次查询，结果集中可以看到T2插入的记录，这条新纪录就是幻想。（事务T1查询，并行事务T2插入/删除部分数据并提交，事务T1再次查询，数据发生改变）
- **不可重复读**：事务T1读取一行记录，紧接着事务T2修改了T1刚刚读取的记录并commit，然后T1再次查询，发现与第一次读取的记录不同，这称为不可重复读。 （事务T1读取一条记录，并行事务T2修改了该记录，事务T1再次查询，数据与第一次读的不同）
- **脏读**：一个事务读取了另一个未提交的并行事务写的数据。事务T1更新了一行记录，还未提交所做的修改，这个T2读取了更新后的数据，然后T1执行回滚操作，取消刚才的修改，所以T2所读取的行就无效，也就是脏数据。（事务T1更新但未提交，事务T2读取到更新后的数据，事务T1回滚，事务T2读取无效）
- **丢失更新**：当两个或多个事务选择同一数据，并且基于最初选定的值更新该数据时，会发生丢失更新问题。（事务T1读取数据，并行事务T2读取同一数据，事务T1更新并提交，事务T2更新并提交，事务T2覆盖事务T1提交结果）

**四种隔离级别**：

- 读未提交：一个事务可以读取另一个未提交事务的数据。

- 读已提交：一个事务必须等另一个事务提交后才能读取数据。（Oracle，SQL Server默认）

- 可重复读：在开始读取数据（事务开启）时，不再允许修改操作。（MySQL默认）

- 串行化：事务串行化顺序执行。效率低下，一般不使用。

  > 读未提交 < 读已提交 < 可重复读 < 序列化



### MySQL索引

索引：为了提高查询速度。

二叉查找树：最好的情况下O(log2n)，最坏O(n)退化为单链表。（查询效率不稳定）

平衡二叉树：结点到叶子结点之间的深度差<=1。（）

B树：平衡多叉搜索树。（查找效率快但不稳定）

利用了程序的局部性原理，有效利用磁盘IO预读能力，引入B+树。

B+树：数据存储在叶子节点。天然排序（提高了区间查找效率）。（磁盘读写代价更低，查询效率稳定）。



MyISAM实现了非聚簇索引，非聚簇索引的主索引与辅助索引一样。

InnoDB实现了聚簇索引。聚簇辅助索引存储的是主键的键值，聚簇索引的辅助索引先找到主索引，再通过主索引找到数据。

聚簇索引的主索引的叶子结点存储的是键值对应的数据本身，辅助索引的叶子结点存储的是键值对应的数据的主键键值。

### 了解PL/SQL





### HTML+CSS





### JS





### Angular





### Redis





### Linux





### Git





### WebMagic



### 数据结构

栈：先进后出。

队列：先进先出。

遍历树：先序遍历（DLR），中序遍历（LDR），后序遍历（LRD）；

```

```



### 设计模式

单例模式：

```java
// 懒汉式
public class Singleton{
	// 定义静态成员实例
    private static Singleton s = null;
	// 私有化构造方法
    private Singleton(){}
	// 静态获取实例
    public static Singleton getInstance(){
        if(s == null){
            s = new Singleton();
        }
        return s;
    }
}
```

```java
// 饿汉式
public class Singleton{
    // 定义final静态成员实例
    private static final Singleton s = new Singleton();
    // 私有化构造方法
    private Singleton(){}
    // 公开静态获取实例方法
    public static Singleton getInstance(){
        return s;
    }
}
```





**装饰设计模式（Decorator）**

装饰设计模式：对类进行功能扩展；

①成员变量：被装饰对象

②构造方法：装饰者要对被装饰对象初始化；

③方法扩展：被装饰类的引用.被扩展的方法；

④规范约束：抽象类，接口；

IO中大量使用了装饰设计模式



### 算法问题

二分查找：

```java
public int binarySearch(int[] a, int key){
    int middle = a.length/2;
    int low = 0;
    int high = a.length-1;
    while(low <= high){
        middle = (low+high)/2;
        if(a[middle] > key){
            high = middle - 1;
        }
    }
}
```

冒泡排序：

```java
public void bubbleSort(int[] a){
    for(int i = a.length - 1; i > 0; i--){
        for(int j = 0; j < i; j++){
            if(a[j] > a[j+1]){
                temp = a[j];
               	a[j] = a[j+1];
                a[j+1] = a[j];
            }
        }
    }
}
```

选择排序：

```java
public void selectSort(int[] a){
    for(int i = 0; i > a.length; i++){
        for(int j = i+1; j > a.length - 1; j++){
            if(a[i] > a[j]){
                temp = a[i];
                a[i] = a[j];
                a[j] = a[i];
            }
        }
    }
}
```

快速排序：

```java
	/*
	 * 快速排序：交换排序 
	 * pivot：枢轴指针; pivotkey：枢轴值，
	 * low：低指针， high：高指针，
	 * partition(数组名称,起始位下标,末尾位下标); 
	 * qSort(数组名称,起始位下标,末尾位下标);
	 */
	// 分区函数，返回枢轴指针
	public int partition(int[] arr, int low, int high) {
		int pivotkey = arr[low];// 设第一个元素为枢轴值
		while (low < high) {
			while (low < high && arr[high] >= pivotkey) {
				high--;
			} // while
			arr[low] = arr[high];
			while (low < high && arr[low] <= pivotkey) {
				low++;
			} // while
			arr[high] = arr[low];
		} // while
		arr[low] = pivotkey;// 将枢轴值 给到 可覆盖区
		return low;// 返回枢轴指针
	}// partition

	// 分区递归
	public void qSort(int[] arr, int low, int high) {
		if (low < high) {
			int pivot = partition(arr, low, high);// 枢轴指针
			qSort(arr, low, pivot - 1);// 前半部分
			qSort(arr, pivot + 1, high);// 后半部分
		}
	}// qSort

	public void quickSort(int[] arr) {
		qSort(arr, 0, arr.length - 1);
	}// quickSort
```

