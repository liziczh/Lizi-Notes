问题：

并发问题，MyBatis，Redis缓存。RabbitMQ。dubbo+zk。



### JavaSE

Java跨平台原理：不同操作系统上有不同的JVM，可以将同一份.class文件执行为不同的机器码。

JVM作用：

① 执行代码：解释执行字节码文件

② 管理内存：将数据加载到内存中去

③ 垃圾回收机制：空闲时间不定时的动态回收无任何引用的对象所占用的空间。（只需new，不用delete）

编译阶段检查语法错误，运行阶段检查内存错误。

#### 数据类型

八大基本数据类型：byte，short，int，long，float，double，char，boolean。

类型提升：① byte，short，char之间不会相互转换，在计算时会自动转换为int类型进行计算。② Java运算时，自动提升至最大数据类型。③ 浮点型运算结果是double。

成员变量有默认值；局部变量无默认值，必须初始化。

#### 运算符

交换两个整数的值，不使用中间变量

（1） x=x+y; y=x-y; x=x-y;

（2）x=x*y; y=x/y; x=x/y;

（3）m=m^n; n=m^n; m=m^n;

使用最快速高效的方式，计算2e3。 位左移1<<3。

判断奇偶数：((num&1)==0) ? “偶数”! “奇数”。

#### 流程控制

switch后的表达式的类型：byte，short，int，char，JDK5引入 枚举；JDK7引入 String；

break：跳出当前循环，跳出一层循环。

continue：跳出本次循环，进行下次循环。

return：结束整个方法，必须是最后一句。

#### 方法

方法的重载（Overload）：方法名相同，参数列表不同（参数个数、类型、顺序不同），与返回值类型无关。

递归：自己调用自己，结束条件跳出递归。

#### 数组

数组初始化：

```java
int[] a = new int[8];
int[] a = {1,2,3,4,5}
// 数组长度：a.length
```

①值传递：基本类型数据传递（传递数据）

②引用传递：引用类型数据传递，参数指针传递；（传递地址）

引用关系：栈内存存放地址，引用堆内存内数据

引用变量值更改：return；

#### Object

equals()：比较两个对象的值是否相等。

hashCode()：返回该对象的哈希码值。

toString()：返回该对象的字符串表示。

**finalize()**：当垃圾回收器确定不存在对该对象的更多引用时（垃圾回收时），由对象的垃圾回收器调用此方法。

> a.对象的finalize方法不一定会被调用，即使是进程退出前
>
> b.发生gc()时一个对象的内存是否被释放取决于是否存在该对象的引用，该对象如果包含成员，那么对象成员遵循本条。
>
> c.对象里包含的对象成员，按声明顺序进行释放。

**Java Object 重写 equals() 方法的同时为什么要重写 hashCode()？** 

因为 equals() 与 hashCode() 必须保持一致；

- 当 obj1.equals(obj2) 为 true，obj1.hashCode() 必须等于 obj2.hashCode()；
- 当obj1.hashCode() == obj2.hashCode()为false时，obj1.equals(obj2)必须为false；

#### String

String：不可变的字符序列，字符数组；字符串常量。

（1）所有字符串都是字符串常量，创建后值不可变。

（2）相同的字符串在字符串常量池中只有一份，常量池数据可共享。

StringBuffer&StringBuilder

- StringBuffer/StringBuilder：可变字符序列，通过某些方法调用可以改变字符序列的长度和内容。
- StringBuffer本质：构造一个其中不带字符的字符串缓冲区。
- StringBuffer()默认容量为 16 个字符。

String与StringBuffer/StringBuilder的区别：

- String是不可变的字符序列（资源利用率低）。
- StringBuffer/StringBuilder是可变的字符序列。

StringBuffer与StringBuilder的区别：

- StringBuffer线程安全但效率低。常用于数据共享，保证线程的安全性和一致性。
- StringBuilder线程不安全。常用于数据独享。

StringBuffer与StringBuilder的联系：StringBuilder是StringBuffer的兼容API。

1.String 获取方法：

- `int length();` 返回字符串长度。
- `char charAt(int index);` 返回指定索引的字符 
- `int indexOf(str1/int ch , [int i]);` 返回指定字符的索引。从第i位开始，第一次出现str1的索引。（ch为char字符的int值）
- `int lastIndexOf(str1/int ch , [int i]);` 返回指定字符的索引。从第i位开始，最后一次出现str1的索引。（ch为char字符的int值）
- `String substring(int start , [int end]);` 字符串截取 [ )
- `String concat(str1 );` 字符串尾接

2.String 判断方法：

- `boolean equalsIgnoreCase(str);` 比较字符串内容是否相同（忽略大小写）
- `boolean contains(str);` 判断是否包含指定字符串str
- `boolean startsWith(str);` 判断是否指定前缀str
- `boolean endsWith(str);` 判断是否指定后缀str
- `boolean isEmpty();` 判断字符串是否为空`""`；

3.String转换方法：

- `byte[] getBytes();` 把字符串转换为字节数组
- `static String valueOf(int i);` 把int型数据转成字符串
- `String toLowerCase();` 把字符串转成小写
- `String toUpperCase();` 把字符串转成大写

4.String其他方法：

- `String replace(oldstr,newstr);` newstr替换oldstr
- `String trim();` 忽略前导空格和尾部空格
- `int compareTo(str1);` 按字典顺序比较两个字符串
- `int compareToIgnoreCase(str);` 按字典顺序比较两个字符串（忽略大小写）

1.StringBuffer常用方法：

- `StringBuilder append(任意类型数据);` 末端追加字符串
- `StringBuilder insert(int offset , 任意类型数据);` 插入字符串
- `StringBuffer deleteCharAt(int index);` 删除指定位置字符
- `StringBuffer delete(int start, int end);` 删除子字符串
- `StringBuffer replace(int start,int end,str);` 替换子字符串
- `String substring(int start,[int end]);` 字符串截取
- `StringBuffer reverse();` 字符串反转（倒序）

#### 基本类型包装类

**基本类型与包装类的区别**：

- 基本类型存储在栈中；包装类存储在堆中。
- 基本类型是值传递；包装类是对象，引用传递调用。

**int与String相互转换**：

int->String：

```java
// 1.Integer 静态方法
Integer.toString(int i);
// 2.String 静态方法
String.valueOf(int i);
```

String->int：

```java
// 1. Integer 静态方法
Integer.parseInt(String s);
// 2.构造方法初始化，再用intValue();
Integer i = new Integer(s);
i.intValue();
```

#### Date

Date->String：

```java
SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd hh:mm:ss");
// format：Date->String
String dateStr = format.format(new Date());
// parse：String->Date
Date date = format.parse("2019-06-01 12:00:00");
```



### 面向对象

万事万物皆对象。将事物抽象化为对象。

面向对象的三大特性：封装、继承、多态。

- 封装：对外隐藏实现细节，提供公共访问方法。
- 继承：子类继承父类的非私有成员。
- 多态：父类的引用指向子类的对象。

类内执行顺序：静态（类加载执行）>非静态（实例化执行），父类>子类，代码块>构造器>成员方法。

#### 类与对象

new：栈内存存储地址，堆内存存储内容。

匿名对象：一次性，栈内没有引用地址。

构造方法：与类名相同，无返回值。创建对象时，由JVM自动调用。

this：代表本类当前对象。this()本类构造方法。

static：静态，类的所有对象共享。随类加载而加载。

final：最终修饰符，不可改变。

#### 继承

继承：子类继承父类的非私有成员。

继承都是单继承，不允许多继承，但可以多层继承。

super：代表父类当前对象。super()父类构造方法。

方法的重写（Override）：子类重写父类成员方法。访问修饰符不能比父类更严格。

静态方法是形式上的继承，本质上不是继承。不能被重写。

#### 多态

多态：父类的引用指向子类的对象。

多态访问类的成员：

- 成员变量：编译看左边，运行看左边。

- 成员方法：编译看左边，**运行看右边**。

- 静态变量/方法：编译看左边，运行看左边。

instanceof：判断该对象是否属于目标类；

```java
obj instanceof ClassA
```

#### 抽象类

抽象类（abstract）：用于被子类继承。不能被实例化，存在构造方法，不能被final修饰。

抽象方法（abstract）：用于被非抽象子类重写。只提供方法声明，不提供方法实现，不能被private、static、final修饰。

抽象方法只存在于抽象类/接口中，但抽象类可以没有抽象方法。

#### 接口

接口（interface）：定义一种规范与标准。

接口不能实例化，没有构造方法，可以多实现。

**抽象类与接口的区别**：

- 抽象类：①不能被实例化，只能被子类继承；②有构造器；③存在抽象方法也存在普通方法。
- 接口：①只能被实现；②没有构造器；③只存在方法声明。

#### 内部类

内部类：定义再类内部，服务于外部类。

成员内部类实例化：外部类.内部类 对象 = new 外部类().new 内部类(); 

> 生成两个class文件：外部类.class，外部类$内部类.class。

方法内部类实例化：方法内实例化。

> 生成两个class文件：外部类.class，外部类$1内部类.class。

访问修饰符：

- public（跨包可访问）
- protected（子类可访问）
- default（包内可访问）
- private（类内可访问）

### 异常

```java
try{
	可能发生异常的代码；
}catch( 异常类型 相应类型变量 ){
	异常处理；（异常发生时执行）
}finally{
	必然执行；（无论异常是否发生，必然执行）
}
```

try块中有return语句，finally语句还会执行吗？在什么时候执行？

- 异常未发生，finally一定会执行；finally先于return执行；

- 异常发生，finally一定会执行，return不执行；

- 异常发生后，try块内异常之后的语句不执行；

### 集合

Collection：List，Set。

- List：ArrayList，Vector，LinkedList。
- Set：HashSet，LinkedHashSet，TreeSet。

Map：HashTable，HashMap，TreeMap。

#### List

List：有序可重复（允许多个null值）

**ArrayList**：基于**可变数组**实现的List。

- 线程不安全，查询快。

**Vector**：基于**可变数组**实现的**线程安全**的List。（已过时）

- 线程安全，查询快。

**LinkedList**：基于**双向链表**实现的List。

- 线程不安全，增删快。

集合在遍历时是否可以修改？

答：不可以。for循环遍历，集合修改后会再赋给原引用；迭代器遍历，不允许集合本身在结构上发生变化。

**CopyOnWriteList**：**读写分离**的ArrayList。

- **读写分离**：写操作在一个复制数组上进行，读操作在原始数组上进行。
- **同步**：写操作加锁同步，写操作完成后，将原始数组指向复制数组。

#### Set

Set：无序不重复（允许一个null值）

**HashSet**：哈希表（无序、唯一）。

- 本质是HashMap的key集。
- 唯一性：equals()和hashCode()。

> **Java Object 重写 equals() 方法的同时为什么要重写 hashCode()？** 
>
> 因为 equals() 与 hashCode() 必须保持一致；
>
> - 当 obj1.equals(obj2) 为 true，obj1.hashCode() 必须等于 obj2.hashCode()；
> - 当obj1.hashCode() == obj2.hashCode()为false时，obj1.equals(obj2)必须为false；
>
> **Java规定对象的eqauls方法和hashCode方法**：
>
> - 相等的对象hashCode必须相等。
> - 两个对象的hashCode相等，它们并不一定相等。

**LinkedHashSet**：链表和哈希表（插入有序、唯一）

- 本质是LinkedHashMap的key集。
- 插入顺序：由链表保证插入顺序，
- 唯一性：由哈希表保证元素唯一。

**TreeSet**：红黑树（元素有序、唯一）

- 本质是TreeMap的key集。
- 元素排序：自然排序、比较器排序。
- 唯一性：根据比较的返回值是否为0决定唯一性。

> 自然排序：通过集合元素类实现Comparable接口，重写compareTo()方法来排序。

#### Map

Map：键值对集合。

**HashTable**：哈希表，线程同步（使用synchronized实现同步）。

- 不允许null键null值。

> 哈希表：一种以键值对存储数据的结构，只需要输入待查找的key，就可直接查找到其对应value，O(1)。

**HashMap**：基于**哈希桶数组**（数组+单链表/红黑树）实现的Map；

- 支持null键null值。
- 生成相同hashCode的不同key存储在同一个bucket下，null健存储在0 bucket下。

> HashMap的底层实现：
>
> 本质上是数组，数组每个元素是链表，链表是为了解决Hash冲突问题。
>
> 当集合添加元素put(key, value)时，使用hash算法（对key调用hashCode()）计算出key的hash值，将hash值与集合长度进行&操作，获取该元素在Map数组中的bucket位置以存储键值对。
>
> 如果该索引上没有元素，直接存放；如果该索引上存在元素且值不相同，则发生hash冲突。
>
> 如果发生hash冲突，以链表的方式链接到后面。
>
> 链表长度>8，转为红黑树；元素个数<6，转为链表（红黑树保持平衡也需要代价）。

**HashTable与HashMap的区别**：

① 关于null：

- HashTable不支持 null-key 和 null-value。HashTable 遇到 null，抛出 NullPointerException。
- HashMap支持 null-key 和 null-value。HashMap 对 null 做了特殊处理，将 null 的 hashCode 值定为了 0，从而将其存放在哈希表的第0个 bucket 中。

② 扩容方式：

- HashTable 默认初始化容量大小为11，之后每次扩充为原来的2n+1。

- HashMap默认初始化容量大小为16，之后每次扩充为原来的2倍。

  > 在取模计算时，如果模数是2的幂，那么我们可以直接使用位运算来得到结果，效率要大大高于做除法。所以从hash计算的效率上，又是HashMap更胜一筹。

③ 线程安全：

- HashTable 线程安全（同步）；

- HashMap 线程不安全（不同步）；

  > HashTable已经被淘汰了，如果你不需要线程安全，使用HashMap；如果你需要线程安全，使用ConcurrentHashMap；

④ 数据结构：

- HashTable 数组+链表
- HashMap 数组+链表/红黑树（JDK1.8）

**ConcurrentHashMap和Hashtable的区别**：

- HashTable 采用 synchronized 实现同步，单锁锁定整个集合，迭代时其他线程必须等待其迭代完成才能访问 map，所以当 Hashtable 的大小增加到一定的时候，性能会急剧下降。
- ConcurrentHashMap 引入了分割（segmentation），仅锁定 map 的某个部分，更适用于高并发。

**fail-fast 与 fail-safe 机制有什么区别**：

- fail-fast（快速失败）：快速失败机制在遍历一个集合时，如果集合内容被修改，会抛出ConcurrentModificationException异常。 
- fail-safe（安全失败）：安全失败机制对集合的任何修改都会在一个复制的集合上进行，因此不会抛出异常。

**TreeMap**：基于红黑树实现的Map；

- 元素排序：自然排序、比较器排序。
- 不允许null键，允许null值。

TreeSet 底层为一个二叉树

- `return 0;` 表示集合中只存一个元素。元素值每次比较，都认为是相同的元素，这时就不再向TreeSet中插入除第一个外的新元素。
- `return 1;` 表示集合正序排列。元素值每次比较，都认为新插入的元素比上一个元素大，于是二叉树存储时，会存在根的右侧，读取时就是正序排列的。
- `return -1;` 表示集合倒序排列。元素值每次比较，都认为新插入的元素比上一个元素小，于是二叉树存储时，会存在根的左侧，读取时就是倒序序排列的。

**比较器排序 `Comparator<T>`** 

创建 TreeSet 类时制定一个 Comparator 接口，重写 compara() 方法制定排序规则。

**红黑树**：自平衡二叉查找树。

- 只有红、黑结点。
- 根是黑结点。
- 叶结点尾端的NIL结点是黑的。
- 红结点的子结点必须都是黑的。
- 对于任意结点，其到叶结点尾端NIL结点的每条路径上都包含相同数目的黑结点。

#### 泛型

**泛型**：为解决集合元素取出时，自动转化成Object类型的问题，在不确定集合类型时，进行集合元素类型的参数化。

泛型擦除：泛型只在编译阶段有效，运行阶段就不存在了；

泛型通配符：

- `<? extends T>` 下限，只能使用T和T的子类；

- `<? super T>` 上限，只能使用T和T的父类；

- `<?>` 未知类型，默认Object类型；

可变参数：定义方法时不确定传入参数的个数，可变参数要位于参数列表的末尾。

```java
(int ... vals);
```



### IO/NIO

#### BIO

IO - 面向**流**的阻塞式IO。

字节流：InputStream，OutputStream。读写二进制数据，图片视频等。

字符流：Reader，Writer。读写纯文本档案。

```java
/* 文件复制
 * int read(byte[] buffer); 读入字节数组，返回读取字节数；
 * void write(byte[] b,int off,int len); 写入数组的某一部分
 */ 
public void copy(File src, File desc) throws IOException {
    InputStream  in = new FileInputStream(src);
    OutputStream out = new FileOutputStream(desc)；
	int len = 0;
	byte[] buffer = new byte[1024];
	while((len = in.read(buffer)) != -1){
		out.write(buffer, 0, len);
	}
    in.close();
    out.close();
}
```

#### NIO

NIO - 面向**缓冲区**，基于**通道**和**选择器**的**同步非阻塞**式IO（线程同步）。

- Buffer存储数据，读写都是操作缓冲区，filp()进行读写模式切换。

- Channel数据载体，多路复用，通过Channel向Buffer读写数据。

- Selector注册通道（同步），允许单线程处理多个Channel，由selector阻塞式地轮询IO事件的就绪。

```java
// 分散读取，聚集写入
while((inChannel.read(bufs)) != -1) {
	for(ByteBuffer b : bufs) {
		b.flip();
		outChannel.write(b);
		b.clear();
	}
}
```



### 多线程 ？

**并发与并行的区别**：

- 并发：多个任务轮询交替执行；

- 并行：多个任务同时执行；

**进程与线程的区别**：

- 进程是资源（CPU、内存等）分配的基本单位，它是程序执行时的一个实例。程序运行时系统就会创建一个进程，并为它分配资源，然后把该进程放入进程就绪队列，进程调度器选中它的时候就会为它分配CPU时间，程序开始真正运行。

- 线程是程序执行时的最小单位，它是进程的一个执行流，是CPU调度和分派的基本单位，一个进程可以由很多个线程组成，线程间共享进程的所有资源，每个线程有自己的堆栈和局部变量。线程由CPU独立调度执行，在多CPU环境下就允许多个线程同时运行。同样多线程也可以实现并发操作，每个请求分配一个线程来处理。

**用户线程与守护线程**：

- 用户线程：前台线程。
- 守护线程：后台线程，守护线程作用是为其他前台线程的运行提供便利服务，而且仅在普通、非守护线程仍然运行时才需要。如果没有用户线程，守护线程也就没有存在下去的意义了。

**Java 创建线程**：

- 继承Thread类，重写run()方法。
- 实现Runnable接口，重写run()方法，本质是 `Thread(Runnable target)` 。

#### 线程的基本状态

![thread-status](img\thread-status.png)

- **新建状态（New）**：创建线程后，进入新建状态。
- **就绪状态（Runnable）**：线程调用 start() 方法进入就绪状态，随时准备获取CPU使用权。
- **运行状态（Running）**：CPU调度该线程，线程获取到CPU使用权，进入运行状态。
- **阻塞状态（Blocked）**：① wait()，进入等待阻塞，② 获取synchronized同步锁时，锁对象被其他线程占用，进入同步阻塞状态，③ sleep()，④ join()，⑤阻塞式 IO 操作；
- **死亡状态（Dead）**：① 线程执行完毕，② 线程异常退出，③ stop()；

**阻塞&阻塞解除**：

- **wait()** 进入阻塞，**notify()** 与 **notifyAll()** 解除阻塞。
- **等待同步锁**进入阻塞，获得同步锁解除阻塞。
- **阻塞式IO**操作进入阻塞，阻塞式IO结束解除阻塞。
- **sleep()** 进入阻塞，睡眠时间到解除阻塞。
- **join()** 进入阻塞。

#### 线程池

```java
public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue, RejectedExecutionHandler handler) 
/*
 * corePoolSize：核心线程数
 * maximumPoolSize：线程池最大线程数
 * keepAliveTime：空闲线程存活时间，线程数>核心线程数时激活。
 * unit：keepAliveTime的时间单位。
 * workQueue：阻塞队列。
 * handler：超出线程范围和队列容量的任务的处理程序
 */
```

① 首先判断核心线程（corePool）是否全部使用。

② 若核心线程全部使用，将任务添加到阻塞队列（workQueue）中。

③ 若阻塞队列已满，比较线程数是否已超过maximumPoolSize。

④ 若未超过最大线程数，则创建新线程去执行任务。

⑤ 当线程池中的线程数>corePoolSize，且存在空闲线程时，回收空闲线程，空闲线程存活时间为keepAliveTime。

#### 线程同步 ？

线程同步：保护共享数据，防止数据不一致；

1.同步方法：synchronized 修饰的方法。

2.同步代码块：

```java
synchronized(obj){}
```

**死锁**

死锁：两个或多个线程互相持有对方所需要的资源，而造成互相等待的状态。

避免死锁：

- 有序分配资源
- **银行家算法**
- 加锁时限

#### 线程通信

**Object类的监视器方法（monitor）**

等待/通知机制

Object监视器方法：wait()、notify()、notifyAll()；

wait()：使线程进入等待状态，如果没有线程来唤醒，则一直处于等待状态；

wait(long timeout)：使线程进入等待状态； 

notify()：唤醒当前处于等待状态的随机一个线程；

notifyAll()：唤醒当前处于等待状态的所有线程；

锁对象执行wait()；和notify()；

**线程同步锁与互斥锁的区别**：

- 同步：多个进程按一定顺序执行；
- 互斥：多个进程在同一时刻只有一个进程能进入临界区。

实现互斥锁：①synchronized关键字，②显式使用lock对象。



### 反射

反射：在程序运行时，通过类的Class对象（类名、对象获取）去动态获取类构造器、属性。

获取类的Class对象

- 对象.getClass()；

- 类.class；

- Class.forName(String className)；全类名；



### JVM ？

栈：主要用来执行java程序，线程私有。

本地方法栈：为执行本地方法分配内存空间；

程序计数器：标记程序执行的跳转和调用；实现选择/循环。

堆内存：新生代（Eden，from，to），老年代，永久代（不属于堆区）；

Eden-->Survive0（from）-->Survive1（to）-->老年代；



### HTTP

HTTP超文本传输协议，无连接，无状态。请求协议+响应协议。请求响应模式。

GET（查）、POST（增）、PUT（改）、DELETE（删）。

- **GET** - 从指定的资源请求数据。一般用于**获取资源信息**。
- **POST** - 向指定的资源提交要被处理的数据。一般用于**更新资源信息**。 

| 操作方式 | GET                     | POST     |
| -------- | ----------------------- | -------- |
| 数据位置 | HTTP包头                | HTTP正文 |
| 数据加密 | 明文（数据暴露在URL中） | 可明可密 |
| 数据安全 | 不安全                  | 安全     |
| 数据长度 | 1KB以下                 | 无限制   |
| 应用场景 | 查询数据                | 修改数据 |



### Tomcat与Nginx

**Tomcat 应用服务器**：支持jsp**动态网页**，Servlet/JSP应用的容器。

**Nginx Web服务器**：只支持**静态网页**html，代理服务器。



### Servlet

Servlet是运行在web服务器端（web容器，如tomcat）的程序。

Servlet处理请求：接受请求数据，处理请求，完成响应。

ServletConfig：Servlet独享。

ServletContext：Web应用共享。



#### Servlet生命周期

①Web浏览器发送http请求给Web应用服务器（tomcat），若Web容器不存在Servlet实例，则容器先加载ServletConfig对象，包含了Servlet初始化配置信息，并创建一个Servlet实例，通过init()初始化实例；

②容器接收到客户端请求，创建一个ServletRequest和ServletResponse对象，接着调用service(request, response)处理请求，然后销毁ServletRequest和ServletResponse对象。

③Web终止时，Servlet容器调用servlet对象的destory()方法销毁Servlet对象和ServletConfig对象。

> init()和destory()方法在整个生命周期内只执行一次。

JSP本质是Java Servlet Pages。将jsp部署到Web容器后，jsp文件会被翻译为index_jsp.java文件。

#### 请求转发与重定向

**forward()**：客户端发送一个请求到服务器，服务器匹配Servlet执行，Servlet处理请求结束，requset调用getRequestDispatcher()方法将请求转发给servlet/jsp。整个过程都在服务器端进行，而且是在同一个请求下完成，因此两个servlet共享一个request，所以请求转发是一个请求一个响应。

```java
request.getRequestDispatcher("/servletDemo2").forward(request,response);
```

**redirect()**：客户端发送一个请求到服务器，服务器匹配Servlet执行，Servlet处理请求结束，response调用sendRedirect()方法，响应给客户端；客户端再重新发送一个新请求给新的servlet/jsp，两个请求互相独立，互不干扰，所以重定向是两个请求两个响应。

```java
response.sendRedirect(String location);
```

- 请求转发是一个请求一个响应，重定向是两次请求。

- 请求转发不改变URL地址，重定向改变URL地址。
- 请求转发共享资源（request/response），重定向不进行资源共享。
- 请求转发只能在一个Web应用程序内进行资源转发，即服务器内部的一种操作。重定向可以用URL绝对路径访问其他Web服务器的资源。
- 重定向效率低，相当于再一次请求；请求转发效率相对较高，跳转仅发生在服务器端。



### Cookie&Session

由于 HTTP 是一种**无状态**协议，浏览器每一次请求都是独立的，无法维持客户端与Web 服务器之间的会话状态，所以引入**会话跟踪**技术，即 **Cookie** 和 **Session** 机制。

Web 应用中的**会话**指一个客户端浏览器与 Web 服务器之间连续发生的一系列请求与响应过程。**会话状态**指 Web 服务器与浏览器在会话过程中产生的状态信息。**SessionID** 用于唯一地标识一个会话的请求信息。

**Cookie机制**

Cookie 机制采用客户端保持HTTP状态信息，存储用户数据。

Cookie 机制：①服务器脚本向客户端浏览器发送一组 Cookie；②客户端浏览器将这些信息存储在本地计算机上；③当下一次浏览器向 Web 服务器发送请求时，浏览器会将这些 Cookie 信息发送到服务器，服务器通过这些 Cookie 信息识别用户。

**Session机制**

Session 机制采用在服务器端记录客户端会话状态信息，存储用户数据。

Session 机制：①在客户端浏览器第一次访问服务器时，Web 服务器为客户端浏览器创建一个会话对象（session 对象），并生成一个对应的 SessionID，服务器把客户端会话状态记录在用户独享的 session 对象中。②在客户端再次访问时，服务器根据客户端携带的 SessionID 从 session 域中查找用户的信息。

Session生命周期

- 创建：在程序中第一次调用HttpServletRequest.getSession(true)方法时就会创建一个新的Session。
- 销毁：①程序调用HttpSession.invalidate();②超时③服务器进程被停止。（关闭浏览器并不能销毁session）

Session 可以存储在服务器上的文件、数据库或者内存中。也可以将 Session 存储在 Redis 这种内存型数据库中，效率会更高。



### JDBC

① 加载和注册驱动：DriverManager；

② 获取数据库连接：Connection；

③ 执行sql语句：Statement，PreStatement；

④ 处理结果集：ResultSet；

⑤ 释放资源：close()；

```java
public class JDBCDemo {
	public static void main(String[] args) {
		// 声明变量
		Connection conn = null;
		Statement stat = null;
		ResultSet res = null;
		List<User> userList = new ArrayList<>();
        
		try {
			// 1.加载和注册驱动
			String driverClassName = "com.mysql.jdbc.Driver";
			Class.forName(driverClassName);
			// 2.获取数据库连接
			String url = "jdbc:mysql:///lizi";
			String ur = "root";
			String pwd = "root";
			conn = DriverManager.getConnection(url, ur, pwd);
			// 3.执行sql查询语句
			stat = conn.createStatement();
			String sql = " select * from user ";
			res = stat.executeQuery(sql);
			// 4.迭代处理结果集
			while(res.next()) {
				User user = new User();
				user.setId(res.getInt("id"));
				user.setUsername(res.getString("username"));
				user.setPassword(res.getString("password"));
				userList.add(user);
			}
		} catch (ClassNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (SQLException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}finally {
			// 5.关闭连接，释放资源
			try {
				// 释放结果集
				res.close();
			} catch (SQLException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}finally {
				try {
					// 释放statement对象
					stat.close();
				} catch (SQLException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}finally {
					try {
						// 关闭数据库连接
						conn.close();
					} catch (SQLException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
			}
		}
	}
}
```

**数据库连接池**：负责分配、管理和释放数据库连接。采用数据库连接池复用连接，减少频繁打开关闭数据库连接的资源开销，提高性能。



### AJAX

AJAX：异步请求，局部刷新。

**AJAX底层**：

（1）创建一个 XMLHttpRequest 对象

（2）`open(String method, String url, boolean async)` - 打开与服务器的连接。

> - method：请求类型，GET / POST；
> - url：文件路径；
> - async：true (异步)，false (同步)，默认为 true；

（3）`send(String data)`  - 将请求的数据发送到服务器。

> - GET请求：`send()`，数据可直接通过 open() 中的URL地址传送。
> - POST请求：`send("key=value&key=value")`，数据以键值对形式发送。
>
> 如果是 POST 请求，则需要在 open() 打开链接后，设置请求头内容类型：
>
> ```js
> xhr.setRequestHeader("Content-Type","application/x-www-form-urlencoded");
> ```

```javascript
function createXMLHttpRequest() {
  var xhr;
  if (window.XMLHttpRequest) {
    //  IE7+, Firefox, Chrome, Opera, Safari 浏览器执行代码
    xhr=new XMLHttpRequest();
  } else {
    // IE6, IE5 浏览器执行代码
    xhr=new ActiveXObject("Microsoft.XMLHTTP");
  }
}
window.onload = function () {
  // 1. 创建一个 XMLHttpRequest 对象
  var xhr = createXMLHttpRequest();
  // 2. 打开与服务器的连接
  xhr.open("POST","/index.jsp",true);
  // -  POST 请求需要设置请求头
  xhr.setRequestHeader("Content-Type","application/x-www-form-urlencoded")
  // 3. 发送数据
  xhr.send("username=scott&password=tiger");
  // 4. 当响应完成&页面正常的情况下，接受响应数据，写入myDiv中。
  xhr.onreadystatechange = function(){
    if (xmlhttp.readyState == 4 && xmlhttp.status == 200){
      document.getElementById("myDiv").innerHTML = xhr.responseText;
    }
  }
}
```

**AJAX使用**：

```javascript
$.ajax({
    type: "GET",
    url: "test.json",
    data: {username:"scott", content:"tiger"},
    dataType: "json",
    success: function(data){
    	// doSomething...
    }
});
```

**跨域CORS**

```java
response.setHeader("Access-Control-Allow-Origin","*");
```

> 支持 GET 和 POST 请求



### SpringIOC

IOC（控制反转）：创建对象控制权的转移，以前创建对象的主动权和时机时由自己控制的。现在将这种权力转移到Spring容器中，并由容器根据配置文件去创建实例和管理各个实例之间的依赖关系，对象与对象之间松散耦合，也利于功能的复用。

DI（依赖注入）：利用Java反射机制，通过调用setter()方法/构造方法进行注入。

**基于Java反射机制实现**：

解析XML文件，获取Bean的class属性，得到Bean的全类名，利用反射机制获取Bean的Class对象，实例化Bean，放入Spring容器中。

**Spring容器BeanFactory与ApplicationContext的区别**：

- BeanFactory：包含了各种Bean的定义，读取bean配置文档，管理bean的加载、实例化，控制bean的生命周期，维护bean之间的依赖关系。

  > BeanFactory采用延迟加载的方式注入Bean，只有使用到某个Bean的时候才加载。

- ApplicationContext：BeanFactory的子类。

  > ApplicationContext在容器启动时，一次性创建了所有的Bean。

**Bean的生命周期**：

1.实例化Bean：BeanFactory，当用户请求一个尚未初始化的bean时，调用createBean进行实例化。ApplicationContext，当容器启动结束后，通过获取BeanDefinition对象中的信息，实例化所有Bean。

2.依赖注入：实例化对象封装在BeanWrapper对象中，Spring根据BeanDefinition对象的信息，通过BeanWrapper的接口完成依赖注入。

**Bean的作用域**：

- singleton：单例（默认）
- prototype：为每个bean请求提供一个实例。
- request：为每一个请求提供一个实例，请求结束后bean失效并被垃圾回收。
- session：为每一个session提供一个实例，session过期后bean失效。
- global-session：全局作用域。

**Spring的单例Beans是线程安全的吗？**

答：Spring没有对单例Bean进行多线程封装处理，关于单例bean的线程安全和并发问题需要开发者自行去搞定。

**Spring如何处理线程并发问题**：

Spring对一些Bean中非线程安全状态采用ThreadLocal机制进行处理，解决多线程中相同变量的访问冲突问题。

- 同步机制采用"时间换空间"机制，不同的线程访问前需要获得锁，没有锁则排队等待。

- ThreadLocal采用"空间换时间"机制，为每一个线程提供一个独立的变量副本，从而隔离了多个线程对数据的访问冲突。



### SpringAOP

**AOP（面向切面编程）**：将交叉业务逻辑织入主业务逻辑中。将与主业务无关的公共行为和逻辑抽取封装为一个可重用模块（即切面），减少系统中的重复代码，降低了模块间的耦合度。比如日志记录、事务管理、权限控制。

- **Aspect（切面）**：声明切面类，包含一些PointCut和Advice。
- **JointPoint（连接点）**：具体织入Advice的连接点。
- **PointCut（切入点）**：一组连接点，定义了相应的Advice将要发生的地方。
- **Advice（通知）**：定义具体的增强通知。
- **Target（目标对象）**：织入Advice的目标对象。

**Advice 通知类型**：`@Before`、`@After`、`@After-Throwing`、`@After-Returning`、`@Around`。

> 增强顺序：@Around环绕通知->@Before前置通知->target method->@Around环绕通知->@After后置通知->@After-Returning返回通知。
>
> @Round与@After-Throwing不能同时使用。

采用动态代理模式实现（JDK动态代理/cglib动态代理）。



### SpringTx

Spring事务种类：

- 编程式事务：TransactionTemplate。
- 声明式事务：AOP，在目标方法开始前加入一个事务，执行结束后进行提交/回滚事务。（@Transactional）

Spring事务隔离级别：事务之间的隔离程度。

```java
public enum Isolation {  
    // 默认数据库隔离级别- 读未提交：
    DEFAULT(-1),
	// 读未提交：一个事务可以读取另一个未提交事务的数据。
    READ_UNCOMMITTED(1),
    // 读已提交：一个事务必须等另一个事务提交后才能读取数据，防止脏读。（Oracle、SqlServer）
    READ_COMMITTED(2),
    // 可重复读：在开始读取数据（事务开启）时，不再允许修改操作。防止脏读、不可重复度。(MySQL)
    REPEATABLE_READ(4),
    // 串行化：事务串行化顺序执行。防止脏读|不可重复度|幻读，但效率低下，一般不使用。
    SERIALIZABLE(8);
}
```

Spring事务传播行为：

```java
public enum Propagation {  
    REQUIRED(0),  // 如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新事务。
    SUPPORTS(1),  // 如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。
    MANDATORY(2), // 如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。
    REQUIRES_NEW(3),  // 创建一个新的事务，如果当前存在事务，则把当前事务挂起。
    NOT_SUPPORTED(4), // 以非事务方式运行，如果当前存在事务，则把当前事务挂起。
    NEVER(5),  // 以非事务方式运行，如果当前存在事务，则抛出异常。
    NESTED(6); // 如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于 REQUIRED 。
}
```

**SpringBoot Tx**：

SpringBoot Tx：使用`@EnableTransactionManagement`开启事务支持，直接使用`@Transactional`注解Service方法即可。

```java
@Transactional(isolation = Isolation.DEFAULT, propagation = Propagation.REQUIRED)
```

SpringBoot 事务管理器：PlatformTransactionManager接口

- spring-boot-starter-jdbc：默认注入DataSourceTransactionManager实例。
- spring-boot-starter-data-jpa：默认注入JpaTransactionManager实例。



### SpringMVC

![springmvc](img\springmvc.jpg)

（1）用户发送请求到DispatcherServlet。

（2）DispatcherServlet收到请求调用HandlerMapping处理器映射器，HandlerMapping根据url找到相应的处理器，返回处理器对象Handler和处理器拦截器链HandlerExecutionChain。

（3）DispatcherServlet通过HandlerAdapter适配器调用具体Handler，返回ModelAndView。

（4）DispatcherServlet将ModelAndView传给ViewReslover视图解析器。

（5）ViewReslover解析后返回具体的View。

（6）DispatcherServlet对View进行视图渲染（数据填充）。

（7）DispatcherServlet将视图响应给用户。



### MyBatis

#{}是预编译处理，${}是字符串替换。



### Spring Data JPA





### SpringBoot

Spring Boot 提供了配置应用程序和框架所需要的基本配置。**简化配置**，内置tomcat。

**SpringBoot 常用启动器**：

spring-boot-starter-web：Web 和 RESTful 应用程序

```java
- Spring - core，beans，context，aop
- Web MVC - （Spring MVC）
- Jackson - for JSON Binding
- Validation - Hibernate,Validation API
- Enbedded Servlet Container - Tomcat
- Logging - logback,slf4j
```

spring-boot-starter-test - 单元测试和集成测试

spring-boot-starter-jdbc - 传统的 JDBC

spring-boot-starter-security - 使用 SpringSecurity 进行身份验证和授权

spring-boot-starter-data-jpa - 带有 Hibeernate 的 Spring Data JPA

**SpringBoot 核心注解**：

@SpringBootApplication：`@SpringBootConfiguration`+`@EnableAutoCOnfiguration`+`@ComponentScan`

**@Configuration与@Component的区别**：

@Configuration中所有@Bean注解的方法都会被动态代理，因此调用该方法返回的都是同一个实例。

@Configuration 本质上还是 @Component。



### 了解SpringCloud

微服务化的核心就是将传统的一站式应用，根据业务拆分成一个一个的服务,彻底地去耦合，每一个微服务提供单个业务功能的服务,一个服务做一件事，从技术角度看就是一种小而独立的处理过程,类似进程概念，能够自行单独启动或销毁拥有自己独立的数据库。



### SQL语句

```sql
SELECT [DISTINCT] <目标列表达式> [AS] <别名>
FROM <表/视图> [AS] <别名>
[WHERE <查询条件>]
[GROUP BY <分组列> [HAVING <分组条件>]]
[ORDER BY <排序列> [ASC|DESC]];
```

WHERE 查询条件：>，<，=，>=，<=，!=，<>

```sql
<列名> [NOT] BETWEEN <下限> AND <上限>
<列名> [NOT] IN （值1, 值2...）
<列名> [NOT] LIKE '<匹配模式>'  // % 替代一个或多个字符，_ 替代一个字符。
```

多重条件：AND，OR，NOT

**WHERE 子句与 HAVING 子句区别**：
①WHERE 子句作用于基本表/视图，不能使用聚集函数。
②HAVING 子句作用于组。

**聚集函数**：

- `COUNT(*)`，`COUNT(<列名>)`，`SUM(<列名>)`，`AVG(<列名>)`，`MAX(<列名>)`，`MIN(<列名>)`。

  > 只有COUNT(*)计算空值，其余都跳过空值。

#### 连接查询

交叉连接：笛卡儿积。

```mysql
SELECT * FROM t1, t2;
SELECT * FROM t1 CROSS JOIN t2;
```

自然连接：去除重复列，消除了笛卡儿积。

```mysql
SELECT * FROM t1 NATURAL JOIN t2;
```

内连接：查询与连接条件匹配的所有行，但不去除重复属性列。

```mysql
SELECT * FROM t1, t2 WHERE t1.a = t2.a;
SELECT * FROM t1 [INNER] JOIN t2 ON t1.a = t2.a;
```

外连接：主表内容全部显示。从表未匹配到的，用NULL填充。

```mysql
SELECT * FROM t1 LEFT JOIN t2 ON t1.a = t2.a;
SELECT * FROM t1 RIGHT JOIN t2 ON t1.a = t2.a;
SELECT * FROM t1 FULL JOIN t2 ON t1.a = t2.a;
```

子查询：

```sql
SELECT <目标列>
FROM <表>
WHERE <列名> <运算符/谓词> 
	(SELECT <目标列>
	 FROM <表>
	 WHERE <查询条件>)
```

派生查询：

```sql
SELECT <目标列>
FROM <表>, (SELECT <目标列> FROM <表> WHERE <查询条件>) [AS] <别名>
WHERE <查询条件>
```

集合查询：UNION（并集去重），UNION ALL（并集不去重），INTERSECT（交集），MINUS（差集）

### 事务-TCL

**事务**：用于**保证数据完整性**。由一组DML语句组成，这组DML语句要么全部成功，要么全部失败。

**事务特性：ACID**：

- **原子性（atomicity）**：一个事务是一个不可分割的工作单位，事务中的一组操作要么全做，要么全不做。
- **一致性（consistency）**：事务必须是使数据库从一个一致性状态变到另一个一致性状态。
- **隔离性（isolation）**：一个事务的执行不能被其他事务干扰。即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。
- **持久性（durability）**：指一个事务一旦提交，它对数据库中数据的改变就应该是永久性的。接下来的其他操作或故障不应该对其有任何影响。

**事务并发不一致**：

- **幻读**：事务T1读取一条指定条件的语句，返回结果集。此时事务T2插入一行新记录并commit，恰好满足T1的条件。然后T1使用相同的条件再次查询，结果集中可以看到T2插入的记录，这条新纪录就是幻想。（事务T1查询，并行事务T2插入/删除部分数据并提交，事务T1再次查询，数据发生改变）
- **不可重复读**：事务T1读取一行记录，紧接着事务T2修改了T1刚刚读取的记录并commit，然后T1再次查询，发现与第一次读取的记录不同，这称为不可重复读。 （事务T1读取一条记录，并行事务T2修改了该记录，事务T1再次查询，数据与第一次读的不同）
- **脏读**：一个事务读取了另一个未提交的并行事务写的数据。事务T1更新了一行记录，还未提交所做的修改，这个T2读取了更新后的数据，然后T1执行回滚操作，取消刚才的修改，所以T2所读取的行就无效，也就是脏数据。（事务T1更新但未提交，事务T2读取到更新后的数据，事务T1回滚，事务T2读取无效）
- **丢失更新**：当两个或多个事务选择同一数据，并且基于最初选定的值更新该数据时，会发生丢失更新问题。（事务T1读取数据，并行事务T2读取同一数据，事务T1更新并提交，事务T2更新并提交，事务T2覆盖事务T1提交结果）

**四种隔离级别**：

- 读未提交：一个事务可以读取另一个未提交事务的数据。

- 读已提交：一个事务必须等另一个事务提交后才能读取数据，防止脏读。（Oracle，SQL Server默认）

- 可重复读：在开始读取数据（事务开启）时，不再允许修改操作，防止脏读、不可重复度。（MySQL默认）

- 串行化：事务串行化顺序执行。防止脏读、不可重复度、幻读，但效率低下，一般不使用。

  > 读未提交 < 读已提交 < 可重复读 < 序列化



### MySQL索引

索引：为了提高查询速度。

二叉查找树：最优平衡二叉树O(log2n)，最差退化为单链表最坏情况下查找效率为O(n)；

平衡二叉树：O(log2n)；缺陷：二叉树深度很深，遍历效率变慢。

B树（多路平衡树）：层级变少，遍历效率提高。

B+树：

- 数据全部存放在叶子结点，非叶结点仅具有索引作用，具有更好的缓存命中率，查询效率稳定。
- 叶子结点相连，天然排序（提高了区间查找效率），（磁盘读写代价更低，查询效率稳定）。

> 程序的局部性访问原理，每次取一页数据到内存可以取到更多的key，有效减少了磁盘IO操作。

聚簇索引：

聚簇索引的主索引的叶子结点存储的是键值对应的数据本身，辅助索引的叶子结点存储的是键值对应的数据的主键键值。

MyISAM实现了非聚簇索引，非聚簇索引的主索引与辅助索引一样。

InnoDB实现了聚簇索引。聚簇辅助索引存储的是主键的键值，聚簇索引的辅助索引先找到主索引，再通过主索引找到数据。



### Redis ？

Redis 数据结构：String，Hash，List，Set，ZSet。

Redis持久化策略：

- RDB：指定时间间隔将内存中的数据集快照写入磁盘（fork过程）。（缺陷：服务器崩掉，上次快照写入时间段到此刻的数据将被丢失）
- AOF：以日志形式记录服务器所处理的每一个DML操作。



### Linux

linux系统启动过程：

#### linux 系统目录结构

- `/bin`：Binary，存放常用命令。
- `/boot`：存放启动linux时使用的一些核心文件，包括连接文件和镜像文件等。
- `/dev`：Device (设备) ，存放 linux 的外部设备。在Linux中访问设备的方式和访问文件的方式是相同的。
- `/etc`：存放系统管理的配置文件与子目录。
- `/home`：用户主目录。在Linux中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的。
- ...

**终端利用ssh登录远程服务器**：

1.安装ssh：

```
yum install ssh
```

2.启动ssh：

```
service sshd start
```

3.登录远程服务器：

```
ssh -p 50022 my@127.0.0.1
输入密码：
my@127.0.0.1:
```

> `-p`：指定端口。
>
> `my`：服务器用户名。
>
> `127.0.0.1`：服务器 IP。

#### linux 文件基本属性

```shell
[root@www /]# ls -l
total 64
drwxr-xr-x 2 root  root  4096 Feb 15 14:46 cron
drwxr-xr-x 3 mysql mysql 4096 Apr 21  2014 mysql
```

![linux文件属性](img/linux-file.png)

第0位：文件类型

- [`d`] - 指目录。
- [`-`] - 指文件。
- [`l`] - 指链接文档。
- [`b`] - 指装置文件里面的可供储存的接口设备(可随机存取装置)。
- [`c`] - 指装置文件里面的串行端口设备，例如键盘、鼠标(一次性读取装置)。

接下来，以三个为一组，均为[`rwx`]的组合。

- [`r`] - read，可读。
- [`w`] - write，可写。
- [`x`] - execute，可执行。
- [`-`] - 没有该权限。

第1、4、7位表示读权限。

第2、5、8位表示写权限。

第3、6、9位表示执行权限。

第1-3位：确定属主 (文件所有者) 权限。

第4-6位：确定属组 (文件所有者的同组用户) 权限。

第7-9位：确定其他用户权限。

**更改文件属性**：

1、chgrp：更改文件属组。

```shell
chgrp [-R] 属组名 文件名
```

> `-R`：递归更改文件属组，就是在更改某个目录文件的属组时，如果加上-R的参数，那么该目录下的所有文件的属组都会更改。

2、chown：更改文件属主，也可同时更改文件属组。

```shell
chown [–R] 属主名 文件名
chown [-R] 属主名：属组名 文件名
```

3、chmod：更改文件9个权限 (owner/group/others 三种身份各自的 read/write/execute 权限) 。

使用数字代表各个权限 (r=4，w=2，x=1) ，这样每组[rwx]都能由一个数字表示。

例如：

> - owner = rwx = 4+2+1 = 7
> - group = rwx = 4+2+1 = 7
> - others= --- = 0+0+0 = 0
>
> 该文件的权限数字就为770。

数字类型改变文件权限：

```shell
chmod [-R] xyz 文件或目录
```

符号类型改变文件权限：

```shell
          u(owner)     +(加入)     r(read)
chmod     g(group)     -(除去)     w(write)     文件或目录
          o(others)    =(设定)     x(execute)
          a(all)
```

#### linux 文件与目录管理

**处理目录常用命令**：

ls：列出目录。

```shell
ls -a  # 列出全部文件（包括隐藏文件）
ls -d  # 仅列出目录本身，而不是列出目录内的文件数据	
ls -l  # 长数据串列出，包含文件的属性与权限等等数据；
```

cd：切换目录。

```shell
cd /opt/app  # 使用绝对路径
cd ./app     # 使用相对路径
cd /   # 根目录
cd ..  # 上一级目录
cd ~   # 家目录，即/root目录
```

pwd：显示当前目录。

mkdir：创建一个新目录。

```shell
mkdir -m  # 配置文件的权限喔！直接配置，不需要看默认权限 (umask) 的脸色～
mkdir -p  # 帮助你直接将所需要的目录(包含上一级目录)递归创建起来！
```

rmdir：删除一个空目录。

```shell
rmdir -p 目录名称  # 连同上一级『空的』目录也一起删除
```

cp：复制文件/目录。

```shell
cp -a  # 相当于 -pdr；
cp -d  # 若来源档为连结档的属性(link file)，则复制连结档属性而非文件本身；
cp -f  # 强制(force)，若目标文件已经存在且无法开启，则移除后再尝试一次；
cp -i  # 若目标档(destination)已经存在时，在覆盖时会先询问动作的进行(常用)
cp -l  # 进行硬式连结(hard link)的连结档创建，而非复制文件本身；
cp -p  # 连同文件的属性一起复制过去，而非使用默认属性(备份常用)；
cp -r  # 递归持续复制，用於目录的复制行为；(常用)
cp -s  # 复制成为符号连结档 (symbolic link)，亦即『捷径』文件；
cp -u  # 若 destination 比 source 旧才升级 destination ！
```

rm：移除文件/目录。

```shell
rm -f  # 强制(force)，忽略不存在的文件，不会出现警告信息；
rm -i  # 互动模式，在删除前会询问使用者是否动作
rm -r  # 递归删除啊！最常用在目录的删除了！这是非常危险的选项！！！
```

mv：移动文件/目录，或修改文件与目录的名称。

```shell
mv -f  # 强制(force)，如果目标文件已经存在，不会询问而直接覆盖；
mv -i  # 若目标文件 (destination) 已经存在时，就会询问是否覆盖！
mv -u  # 若目标文件已经存在，且 source 比较新，才会升级 (update)
```

> man [命令]：查看各个命令的使用文档。

**查看文件内容**：

cat：从第一行开始显示文件内容。

- -A ：相当于 -vET 的整合选项，可列出一些特殊字符而不是空白而已；
- -b ：列出行号，仅针对非空白行做行号显示，空白行不标行号！
- -E ：将结尾的断行字节 $ 显示出来；
- -n ：列印出行号，连同空白行也会有行号，与 -b 的选项不同；
- -T ：将 [tab] 按键以 ^I 显示出来；
- -v ：列出一些看不出来的特殊字符

tac：从最后一行开始显示文件内容。

nl：带行号显示内容。

- -b ：指定行号指定的方式，主要有两种：
  -b a ：表示不论是否为空行，也同样列出行号(类似 cat -n)；
  -b t ：如果有空行，空的那一行不要列出行号(默认值)；
- -n ：列出行号表示的方法，主要有三种：
  -n ln ：行号在荧幕的最左方显示；
  -n rn ：行号在自己栏位的最右方显示，且不加 0 ；
  -n rz ：行号在自己栏位的最右方显示，且加 0 ；
- -w ：行号栏位的占用的位数。

more：以页为单位显示文件内容。

- 空白键 (space)：代表向下翻一页；
- Enter         ：代表向下翻『一行』；
- /字串         ：代表在这个显示的内容当中，向下搜寻『字串』这个关键字；
- :f            ：立刻显示出档名以及目前显示的行数；
- q             ：代表立刻离开 more ，不再显示该文件内容。
- b 或 [ctrl]-b ：代表往回翻页，不过这动作只对文件有用，对管线无用。

less：与more类似，可以向前翻页。

- 空白键    ：向下翻动一页；
- [pagedown]：向下翻动一页；
- [pageup]  ：向上翻动一页；
- /字串     ：向下搜寻『字串』的功能；
- ?字串     ：向上搜寻『字串』的功能；
- n         ：重复前一个搜寻 (与 / 或 ? 有关！)
- N         ：反向的重复前一个搜寻 (与 / 或 ? 有关！)
- q         ：离开 less 这个程序；

head：只看前几行。

- -n ：后面接数字，代表显示几行的意思

tail：只看最后几行。

- -n ：后面接数字，代表显示几行的意思

**linux 文件链接**：

- 硬连接：通过索引节点来进行连接。相当于 Windows 复制。
- 软连接：符号链接，相当于 Windows 快捷方式。

#### linux 用户与用户组管理

**用户账号管理**：

1、添加新账号：

```shell
useradd 选项 用户名
```

- -c comment 指定一段注释性描述。
- -d 目录 指定用户主目录，如果此目录不存在，则同时使用-m选项，可以创建主目录。
- -g 用户组 指定用户所属的用户组。
- -G 用户组，用户组 指定用户所属的附加组。
- -s Shell文件 指定用户的登录Shell。
- -u 用户号 指定用户的用户号，如果同时有-o选项，则可以重复使用其他用户的标识号。

2、删除账号：

```shell
userdel 选项 用户名
```

- -r 把用户的主目录一起删除。

修改账号：

```shell
usermod 选项 用户名
```

> 选项同useradd。

3、指定口令：

```
passwd 选项 用户名
```

- -l 锁定口令，即禁用账号。
- -u 口令解锁。
- -d 使账号无口令。
- -f 强迫用户下次登录时修改口令。

**用户组管理**：

1、添加用户组

```
groupadd 选项 用户组
```

- -g GID 指定新用户组的组标识号（GID）。
- -o 一般与-g选项同时使用，表示新用户组的GID可以与系统已有用户组的GID相同。

2、删除用户组

```shell
groupdel 用户组
```

3、修改用户组

```shell
groupmod 选项 用户组
```

- -g GID 为用户组指定新的组标识号。
- -o 与-g选项同时使用，用户组的新GID可以与系统已有用户组的GID相同。
- -n新用户组 将用户组的名字改为新名字

4、切换用户组

```shell
newgrp 用户组
```

#### linux 磁盘管理

df：列出文件系统的整体磁盘使用量

```shell
df [-ahikHTm] [目录或文件名]
```

- -a ：列出所有的文件系统，包括系统特有的 /proc 等文件系统；
- -k ：以 KBytes 的容量显示各文件系统；
- -m ：以 MBytes 的容量显示各文件系统；
- -h ：以人们较易阅读的 GBytes, MBytes, KBytes 等格式自行显示；
- -H ：以 M=1000K 取代 M=1024K 的进位方式；
- -T ：显示文件系统类型, 连同该 partition 的 filesystem 名称 (例如 ext3) 也列出；
- -i ：不用硬盘容量，而以 inode 的数量来显示

du：检查磁盘空间使用量

```
du [-ahskm] 文件或目录名称
```

- -a ：列出所有的文件与目录容量，因为默认仅统计目录底下的文件量而已。
- -h ：以人们较易读的容量格式 (G/M) 显示；
- -s ：列出总量而已，而不列出每个各别的目录占用容量；
- -S ：不包括子目录下的总计，与 -s 有点差别。
- -k ：以 KBytes 列出容量显示；
- -m ：以 MBytes 列出容量显示；

fdisk：磁盘分区表操作工具

```
fdisk [-l] 装置名称
```

- -l ：输出后面接的装置所有的分区内容。若仅有 fdisk -l 时， 则系统将会把整个系统内能够搜寻到的装置的分区均列出来。

#### linux vi/vim

![](img/vi-vim-cheat-sheet-sch.gif)

vim 三种模式：命令模式（Command mode），输入模式（Insert mode）和底线命令模式（Last line mode）。

1、命令模式：一般模式，查看文本。

- `i`、`a`、`o`：切换输入模式；
- `:`：切换底线命令模式；
- `x`：删除当前光标所在处的字符；

2、输入模式：编辑文本。

- `ESC`：退出输入模式，切换到命令模式；

3、底线命令模式：

- `q`：quit，退出；
- `w`：保存文件；

**一般模式**：

1、移动光标：

`h`、`←`：光标向左移动；

`j`、`↑`：光标向上移动；

`k`、`↓`：光标向下移动；

`l`、`→`：光标向右移动；

> h、j、k、l 键盘位置相连。

`PgDn`、`[Ctrl]+[f]`：向下移动一页；

`PgUp`、`[Ctrl]+[b]`：向上移动一页；

`[Ctrl]+[d]`：向下移动半页；

`[Ctrl]+[u]`：向上移动半夜；

`+`：下一行；

`-`：上一行；

`20<space>`：移动到光标后20个字符处；

`0`、`[Home]`：段首；

`$`、`[End]`：段末；

`H`：移动到屏幕最上行的首字符；

`M`：移动到屏幕中央行的首字符；

`L`：移动到屏幕最下行的首字符；

`G`：最后一行；

`20G`：移动到第20行；

`gg`：首行，相当于 `1G` ；

`20<Enter>`：移动到光标后20行；

2、查找替换：

`/word`：向下寻找字符串；

`?word`：向上寻找字符串；

`[n]`：next，向下继续搜寻；

`[N]`：向上继续搜寻；

`:100,200s/word/WORD/g`：在第100行-200行之间查找word，并将其替换为WORD。

`:100,200s/word/WORD/gc`：在第100行-200行之间查找word，请用户确认后将其替换为WORD。

3、删除、复制与粘贴

`x`：相当于 `[del]` ；

`X`：相当于`[Backspace]`；

`10x`：连续`[del]`10个字符；

`dd`：删除整行；

`10dd`：删除10行；

`d1G`：删除光标到第一行的数据；

`dG`：删除光标到最后一行的数据；

`d0`：删除光标到该行第一个字符的数据；

`d$`：删除光标到该行最后一个字符的数据；

`yy`：复制整行；

`10yy`：向下复制10行；

`y1G`：复制光标到第一行的数据；

`yG`：复制光标到最后一行的数据；

`y0`：复制光标到该行第一个字符的数据；

`y$`：复制光标到该行最后一个字符的数据；

`p`：粘贴在光标下一行；

`P`：粘贴在光标上一行；

`J`：将光标所在行与下一行的数据结合成同一行；

`u`：撤销；

`[Ctrl]+r`：重做上一个动作；

`.`：重复前一个动作；

**一般模式切换到编辑模式**：

`i`：从目前光标所在处输入；

`I`：在目前所在行的第一个非空格符处开始输入；

`a`：从目前光标所在的下一个字符处开始输入；

`A`：从光标所在行的最后一个字符处开始输入

`o`：在目前光标所在的下一行处输入新的一行；

`O`：在目前光标所在处的上一行输入新的一行；

`r`：取代光标所在的那一个字符一次；

`R`：进入取代模式，取代光标所在的文字；

**一般模式切换到指令行模式**：

`:w`：写入硬盘；

`:w!`：强制写入；具体能否写入，与用户权限有关；

`:q`：退出；

`:q!`：强制退出且不保存变更；

`:wq`：保存退出；

`ZZ`：若文件未变动，则不保存退出；若文件变动，则保存退出；

`:w [filename]`：另存为；

`:r [filename]`：读入其他文件数据；

`:n1,n2 w [filename]`：将 n1 到 n2 的内容保存新文档；

`! command`：暂时离开vim，前去执行命令；

`:set nu`：设置行号；

`:set nonu`：取消行号；

#### linux yum

yum（ Yellow dog Updater, Modified）是一个在Fedora和RedHat以及SUSE中的Shell前端软件包管理器。

基於RPM包管理，能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软体包，无须繁琐地一次次下载、安装。

```shell
yum [options] [command] [package ...]
```

1、检查更新：列出所有可更新的软件清单命令；

```
yum check-update
```

2、更新所有软件：

```shell
yum update
```

3、仅安装指定软件：

```shell
yum install <package_name>
```

4、仅更新指定软件：

```shell
yum update <package_name>
```

5、检查安装：列出所有可安裝的软件清单；

```shell
yum list
```

6、删除软件包：

```shell
yum remove <package_name>
```

7、查找软件包：

```shell
yum search <keyword>
```

8、清缓存：

```shell
yum clean packages   # 清除缓存目录下的软件包
yum clean headers    # 清除缓存目录下的 headers
yum clean oldheaders # 清除缓存目录下旧的 headers
yum clean   # 清除缓存目录下的软件包及旧的headers
yum clean all  # 同 yum clean
yum clean packages # 同 yum clean
yum clean oldheaders # 同 yum clean
```

### Git

#### 0. Git 基本操作

0.1 创建一个新的仓库 

```shell
$ git init
$ git add .
$ git commit -m "initial commit"
$ git remote add origin <url>
$ git push origin master
```

0.2 记录每次更新到远程仓库 

```shell
$ git add .
$ git commit -m "initial commit"
$ git push origin master
```

#### 1. Git 配置

1.1 配置用户信息

```shell
# git配置用户名
$ git config --global user.name "username"
# git配置用户邮箱
$ git config --global user.email useremail@example.com
```

1.1 查看配置信息

```shell
$ git config --list
```

#### 2. Git 本地仓库

2.1 创建本地仓库

```shell
# git初始化本地仓库
$ git init
```

将当前所在目录初始化为一个本地仓库。初始化完成后，在当前目录下会出现一个名为 `.git` 的目录，所有 Git 需要的数据和资源都存放在这个目录中，切记不要手动修改该目录下的任何文件。

2.2 克隆远程仓库到本地

```shell
# 克隆远程仓库的默认分支
$ git clone <url>
# 克隆远程仓库的指定分支
$ git clone -b <branch-name> <url>
```

> git支持多种数据传输协议：
>
> - ssh协议：`user@server:/path.git`
> - https协议： `http(s)://` 
> - git协议： `git://` 

#### 3. Git 版本控制

**git 工作流程**：

![git版本控制](http://p6uturdzt.bkt.clouddn.com/git-filestream.png)

#### 3.1 查看文件状态

```shell
# 查看仓库文件状态
$ git status
```

**git 文件状态变化**：

![git文件状态](http://p6uturdzt.bkt.clouddn.com/git-filestatus.png)

3.2 暂存修改

`git add` ：①跟踪未跟踪文件，②将已跟踪文件放入暂存区。

```shell
# 跟踪所有文件，暂存所有修改
$ git add .
# 跟踪某个文件，暂存某个文件修改
$ git add <file-name>
```

3.3 撤销文件修改

```shell
# 撤销文件修改
$ git checkout --<file>
```

3.4 提交更新

`git commit` ：将本次更新全部提交到本地仓库。

```shell
# 提交已暂存更新
$ git commit -m "提交说明"
# 暂存并提交更新
$ git commit -am "提交说明"
```

3.5 查看提交日志

```shell
# 查看提交日志
$ git log
```

3.6 版本回退

**1. 软回退**：只回退commit信息。

```shell
$ git reset --soft HEAD^
```

**2. 默认回退**：回退commit和index信息，只保留本地源码。

```shell
$ git reset --mixed HEAD^
```

**3. 硬回退**：commit、index信息、本地源码全部回退。

```shell
$ git reset --hard HEAD^
```

> 版本的表示方式：
>
> - `HEAD^` 上一版本，`HEAD^^` 上上个版本 ...... 
> - `HEAD~n`：上n个版本
> - `<commit_id>`：某个指定版本

#### 4. Git 远程仓库

4.1 添加远程仓库

```shell
# 添加一个远程仓库
$ git remote add <remote-name> <url>
```

4.2 移除远程仓库

```shell
# 移除某个远程仓库
$ git remote rm <remote-name>
```

4.3 重命名远程仓库

```shell
# 重命名远程仓库
$ git remote rename <old-name> <new-name>
```

4.4 查看远程仓库

```shell
# 查看所有远程仓库
$ git remote -v
```

4.5 从远程仓库抓取数据

```shell
# 从远程仓库抓取数据
$ git fetch <remote-name>
```

4.6 推送数据到远程仓库

```shell
# 推送数据到远程仓库
$ git push <remote-name> <branch-name>
```

#### 5. Git 分支

Git 分支原理：每一个分支存在一个分支指针，分支指针指向不同版本；
Git 分支切换：HEAD 指针指向某个分支指针；

5.1 创建分支

```shell
# 创建一个分支
$ git branch <branch-name>
```

5.2 切换分支

```shell
# 切换分支
$ git checked <branch-name>
#  创建并切换到该分支
$ git checked -b <branch-name>
```

5.3 合并分支

```shell
# 合并分支
$ git merge <other-branch>
```

5.4 删除分支

```shell
# 删除分支
$ git branch -d <branch-name>
```

5.5 查看分支

```shell
# 查看所有分支
$ git branch -v
```

#### 6. GitHub Fork

Fork即派生项目。在GitHub社区中可以Fork任意开源仓库。Fork之后，GitHub 将在你的空间中创建一个项目副本，你对项目副本拥有读写权限。并且可以推送pull request给官方仓库贡献代码。

**Fork 流程**：

1. 从 master 分支中创建一个新分支
2. 提交一些修改到新分支来改进项目
3. 将这个分支推送到 GitHub 上
4. 创建一个合并请求(Pull Request)
5. 项目的拥有者合并或关闭你的合并请求

#### 7. gitignore

.gitignore文件规范：

- `#`：注释
- `!`：取反
- `*`：任意长度字符
- `?`：匹配单个字符
- `[abc]`：匹配方括号中的任意单个字符
- `[0-9]`：匹配两个字符之间的任意字符
- `**`：匹配任意中间目录
- 以`/`开头防止递归
- 以`/`结尾指定目录



### 数据结构

栈：先进后出。

队列：先进先出。

遍历树：先序遍历（DLR），中序遍历（LDR），后序遍历（LRD）；

**哈希表**：一种以键值对存储数据的结构，只需要输入待查找的key，就可直接查找到其对应value，O(1)。

**红黑树规则**：自平衡二叉查找树。

- 只有红、黑结点。
- 根是黑结点。
- 叶结点尾端的NIL结点是黑的。
- 红结点的子结点必须都是黑的。
- 对于任意结点，其到叶结点尾端NIL结点的每条路径上都包含相同数目的黑结点。

### 设计模式

单例模式：

```java
// 懒汉式
public class Singleton{
	// 定义静态成员实例
    private static Singleton s = null;
	// 私有化构造方法
    private Singleton(){}
	// 静态获取实例
    public static Singleton getInstance(){
        if(s == null){
            s = new Singleton();
        }
        return s;
    }
}
```

```java
// 饿汉式
public class Singleton{
    // 定义final静态成员实例
    private static final Singleton s = new Singleton();
    // 私有化构造方法
    private Singleton(){}
    // 公开静态获取实例方法
    public static Singleton getInstance(){
        return s;
    }
}
```

工厂模式：



JDK动态代理：



cglib动态代理：



### 算法问题

二分查找：

```java
public int binarySearch(int[] a, int key){
    int middle = a.length/2;
    int low = 0;
    int high = a.length-1;
    while(low <= high){
        middle = (low+high)/2;
        if(a[middle] > key){
            high = middle - 1;
        }else if(a[middle] < key){
        	low = middle + 1;
        }else{
            return middle;
        }
    }
    return -1;
}
```

冒泡排序：时间复杂度O(n^2)

```java
public void bubbleSort(int[] a){
    for(int i = a.length - 1; i > 0; i--){
        for(int j = 0; j < i; j++){
            if(a[j] > a[j+1]){
                swap(a, j, j+1);
            }
        }
    }
}
```

选择排序：时间复杂度O(n^2)

```java
public void selectSort(int[] a){
    for(int i = 0; i > a.length; i++){
        for(int j = i+1; j > a.length - 1; j++){
            if(a[i] > a[j]){
                swap(a, i, j)
            }
        }
    }
}
```

快速排序：平均时间复杂度O(nlogn)，最好空间复杂度O(logn)，最坏空间复杂度O(n)

```java
	/*
	 * 快速排序：交换排序 
	 * pivot：枢轴指针; pivotkey：枢轴值，
	 * low：低指针， high：高指针，
	 * partition(数组名称,起始位下标,末尾位下标); 
	 * qSort(数组名称,起始位下标,末尾位下标);
	 */
	// 分区函数，返回枢轴指针
	public int partition(int[] arr, int low, int high) {
		int pivotkey = arr[low];// 设第一个元素为枢轴值
		while (low < high) {
			while (low < high && arr[high] >= pivotkey) {
				high--;
			} // while
			arr[low] = arr[high];
			while (low < high && arr[low] <= pivotkey) {
				low++;
			} // while
			arr[high] = arr[low];
		} // while
		arr[low] = pivotkey;// 将枢轴值 给到 可覆盖区
		return low;// 返回枢轴指针
	}// partition

	// 分区递归
	public void qSort(int[] arr, int low, int high) {
		if (low < high) {
			int pivot = partition(arr, low, high);// 枢轴指针
			qSort(arr, low, pivot - 1);// 前半部分
			qSort(arr, pivot + 1, high);// 后半部分
		}
	}// qSort

	public void quickSort(int[] arr) {
		qSort(arr, 0, arr.length - 1);
	}// quickSort
```

### 计算机网络

网络的七层协议：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。

**TCP的三次握手和四次挥手**：

三次握手：Client 发送 SYN（seq=j）包到 Server，Server 响应 SYN+ACK（ack=j+1, seq=k）包到Client，Client发送确认包ACK（ack=k+1）。

四次挥手：Client 发送 FIN（seq=u）包到 Server，Server 响应 ACK（ack=u+1）包到 Client。Server 发送 FIN（seq=w）包到 Client，Client 响应 ACK（ack=w+1）包到 Server。

**TCP与UDP区别**：

TCP：面向连接，点对点，提供可靠服务。

UDP：无连接，一对一、一对多、多对一、多对多，尽最大努力交付。

