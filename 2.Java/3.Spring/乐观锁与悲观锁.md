##### 乐观锁与悲观锁

并发控制是为了保证多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性

乐观锁适用于读多写少，悲观所适用于写多读少。

##### 悲观锁（Pessimistic Lock）

悲观锁是对数据修改持悲观态度的并发控制方式，是**“先取锁再访问”**的保守策略，适用于写多读少的场景。每次读取数据的时候都默认其他线程会更改数据，因此每次都要加锁，其他线程想要访问数据都会被阻塞挂起。

悲观锁的实现：

1.关系型数据库的锁机制：行锁、表锁、读锁、写锁等

2.Java的synchronized关键字、ReentrantLock等独占锁。

共享锁（share locks）：读锁，S锁。共享锁就是多个事务操作同一数据可以共享一把锁，都能访问数据。获取共享锁的事务可读不可写。

排他锁（exclusive locks）：写锁，X锁。排他锁就是不能与其他锁并存，如果一个事务获得了一个数据的排他锁，那么这个事务就不能再获取这个数据的其他任何锁。获取排他锁的事务对数据可读可写。 

###### for update

悲观锁实例：select ... for update会将数据锁住。

```sql
-- 开始事务
begin;
-- 查询商品库存信息
select stock from product where id = 1 for update;
-- 修改商品库存为2
update product set stock = 2 where id = 1;
-- 提交事务
commit;
```

MySQL InnoDB 默认行级锁，行级锁都是基于索引的，如果一条 SQL 语句用不到索引是不会使用行级锁的，会使用表级锁将整张表锁住。

##### 乐观锁（Optimistic Lock）

乐观锁是相信并发控制中事务间数据竞争概率是较小的，在提交更新的时候，分两步：**冲突检测和数据更新**。乐观锁适用于读多写少的场景，可提高程序的吞吐量。

乐观锁的实现：

1.CAS算法实现：比较与替换

2.版本号机制：使用version字段记录数据修改次数，当执行更新操作时，比较之前读到的version值与当前数据库中的version值，若相等才可以执行更新操作，否则重试更新操作直至更新成功。

###### CAS（Compare And Swap）

多个线程使用CAS同时更新同一个数据的时候，只有一个线程可以更新数据值，其他线程都会失败，失败线程并不会被挂起，而是被告知失败并可重试。

```sql
-- 查出商品库存信息，此时stock=3 
select stock from product where id = 1;
-- 修改商品库存为2
update product set stock = 2 where id =1 and stock = 3;
```

ABA问题：第一次读到的值为A，然后再赋值时检查它的值仍是A。我们不能认定其中间值未发生改变，可能存在其他线程修改值为B，又修改为A的情况。

自旋问题：失败重试直至成功，如果长时间不成功，会消耗过多的CPU执行资源。
