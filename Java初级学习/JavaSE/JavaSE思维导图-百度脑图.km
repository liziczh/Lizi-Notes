{"root":{"data":{"id":"da2154edcfaf","created":1519547369,"text":"Java","expandState":"expand"},"children":[{"data":{"id":"bjm2lkjhuw0k","created":1519547404254,"text":"JavaSE基础","expandState":"collapse","layout":null},"children":[{"data":{"id":"bjm3267vcf4g","created":1519548705267,"text":"Java编程基础","layout":null,"expandState":"expand"},"children":[{"data":{"id":"bjm32vo2svks","created":1519548760683,"text":"Java开发入门","font-family":"微软雅黑,Microsoft YaHei","layout":null,"expandState":"collapse"},"children":[{"data":{"id":"bjm332319k8o","created":1519548774632,"text":"一、Java语言特点","font-family":"微软雅黑,Microsoft YaHei","note":"1.简单性：取消了C++的指针和多继承\n2.面向对象：封装、继承、多态；\n3.编译和解释性：\n4.可移植性：跨平台，一次编译，处处运行。（JVM）\n跨平台原理：Java语言跨平台，JVM不跨平台。\n由于不同平台上有不同的JVM，可以将同一份*.class执行为不同的机器码。","layout":null,"expandState":"expand"},"children":[]},{"data":{"id":"bjm33iex85c0","created":1519548810179,"text":"二、JDK，JRE，JVM","font-family":"微软雅黑,Microsoft YaHei","note":"JDK（Java Development Kit）：Java开发工具包，程序开发使用；编译；\nJRE（Java Runtime Environment）：Java运行环境；运行；\nJVM：解释执行字节码文件（.class→相应OS机器码）\nJVM作用：\n①执行代码：解释执行字节码文件\n②管理内存：将数据加载到内存中去\n③垃圾回收机制：空闲时间不定时的动态回收无任何引用的对象所占用的空间。（只需new，不用delete）","layout":null,"expandState":"expand"},"children":[]},{"data":{"id":"bjm35qzggqgw","created":1519548985563,"text":"三、Java开发环境搭建","layout":null,"expandState":"collapse"},"children":[{"data":{"id":"bjm35yrxu00k","created":1519549002523,"text":"（一）JDK安装","note":"1.从oracle官网下载JDK\n2.双击.exe文件安装：安装路径不允许出现中文、空格、@#$等特殊字符。","layout":null,"expandState":"expand"},"children":[]},{"data":{"id":"bjm3658yxlsg","created":1519549016613,"text":"（二）验证JDK安装是否正确","note":"cmd：Windows系统→命令提示符 || win+R→输入cmd。\njava -version","layout":null,"expandState":"expand"},"children":[]},{"data":{"id":"bjm36hp3wg00","created":1519549043711,"text":"（三）配置path环境变量","note":"Path：可执行文件的路径；\nJAVA_HOME：D:\\LiziChen\\Java\\JDK\n相对路径Path：%JAVA_HOME%\\bin;（引用JAVA_HOME）\n绝对路径Path：D:\\LiziChen\\Java\\JDK\\bin;\npath 环境变量是系统环境变量中的一种，它用于保存一系列可执行文件的路径，每个路径之间以分号分隔。当在命令行窗口运行一个可执行文件时，操作系统首先会在当前目录下查找是否存在该文件，如果不存在会继续在 path 环境变量中定义的路径下去寻找这个文件，如果仍未找到，系统会报错。","layout":null,"expandState":"expand"},"children":[]},{"data":{"id":"bjm37skjkgg8","created":1519549145743,"text":"（四）配置classpath","note":"classPath：指定class文件的路径；\nCLASSPATH=.;%JAVA_HOME%/lib/dt.jar;%JAVA_HOME%/lib/tools.jar\nclasspath 环境变量也是系统环境变量中的一种，它用于保存一系列类（.class）文件的路径。当 Java 虚拟机需要运行一个类时，会先在 classpath 环境变量中所定义的路径下去寻找所需的 class 文件。如果 classpath 的路径最后有分号，则在 classpath 中找不到时，再到当前路径查找；如果最后无分号，则只在 classpath 设置的路径中查找。\n\n","layout":null,"expandState":"expand"},"children":[]}]},{"data":{"id":"bjm399012io0","created":1519549259872,"text":"四、Java程序","font-family":"微软雅黑,Microsoft YaHei","layout":null,"expandState":"collapse"},"children":[{"data":{"id":"bjm39e67fwo4","created":1519549271130,"text":"（一）第一个Java程序：HelloWorld.java","note":"public class HelloWorld{\n\tpublic static void main(String[] args){\n\t\tSystem.out.println(\"HelloWorld\");\n\t}\n}\n1.编译源文件：javac HelloWorld.java\n2.运行程序：java HelloWorld\n3.输出结果：HelloWorld","layout":null,"expandState":"expand"},"children":[]},{"data":{"id":"bjm39rg6ct4c","created":1519549300031,"text":"（二）Java程序的执行","note":"1.编写Java源代码（*.java）\n2.源程序编译成字节码文件（*.class）\n3.JVM执行*.class文件","layout":null,"expandState":"expand"},"children":[]},{"data":{"id":"bjm3a1blyjkg","created":1519549321522,"text":"（三）Java代码规范","note":"1.代码要有层次\n2.代码要有缩进，{}内缩进一个table\n3.先写结构，再填充内容。（保证符号不出错）\n4.运算符两端与操作数之间预留空格。\n5.if(){ }、for(){ }、while(){ }、do{ }while()即使只有一条语句，也不要省略{}。","layout":null,"expandState":"expand"},"children":[]},{"data":{"id":"bjm3c669lwws","created":1519549488812,"text":"（四）Java文件规范","note":"1.文件名=public修饰的类名\n2.在一个Java文件中，可以有多个类，只能存在一个public类\n3.在一个Java文件中，在public类中，只能存在一个标准main方法","layout":null,"expandState":"expand"},"children":[]}]},{"data":{"id":"bjm3cubfes08","created":1519549541367,"text":"五、注释","note":"注释：方便程序阅读而写的一系列说明文字；提高代码可读性。 \n1.单行注释：\t//单行注释\n2.多行注释：\t/*多行注释\n*多行注释不可嵌套多行注释/*...*/\n*多行注释可以嵌套单行注释//\n*/\n3.文档注释：\t/**文档注释\n@author 开发该类模板的作者\n@version 该类模板的版本\n@param 对方法中某参数的说明\n@return 对方法返回值的说明\n@exception 对方法可能异常进行说明\n*/\n\t使用javadoc命令生成html说明文档\njavadoc -d doc HelloWorld.java\n-d doc:文件位置","font-family":"微软雅黑,Microsoft YaHei","expandState":"expand"},"children":[]},{"data":{"id":"bjm3dp3nm9kw","created":1519549608377,"text":"附、常用Dos命令","note":"1.切换盘符：直接键入盘符+“:”，例如d:\n2.进入指定目录：cd 要进入的路径\n3.cd.. 目录回退一级，cd/ 回退到当前盘符根目录\n4.查看IP地址：ipconfig；ipconfig -all；\n5.检查网络连通性：ping IP地址/网址，发送四次\n                      ping IP地址 -t，持续发送数据包\n6.结束dos窗口：Ctrl+C\n7.清屏：cls\n8.查看当前目录下的文件/子文件：dir\n9.打开注册表：win+R，输入regedit\n","expandState":"expand"},"children":[]}]},{"data":{"id":"bjm3eo9flz40","created":1519549684914,"text":"Java基本语法","expandState":"collapse"},"children":[{"data":{"id":"bjm3eypdzrsc","created":1519549707646,"text":"数据类型与运算符","expandState":"collapse"},"children":[{"data":{"id":"bjm3fdth2n4g","created":1519549740545,"text":"一、标识符","note":"标识符：自定义名称\n包名、类名、方法名、接口名、参数名","expandState":"collapse"},"children":[{"data":{"id":"bjm3fme6seo8","created":1519549759212,"text":"（一）Java标识符命名规则","note":"①只能是字母，数字，下划线_,美元$\n②严格区分大小写，a与A不同（字母约束）\n③不能使用Java关键字和保留字（字母约束）\n④不能以数字开头（数字约束）\n⑤命名支持中文，但不允许使用（字符约束）\n⑥理论上，命名长度不受限制"},"children":[]},{"data":{"id":"bjm3g4j4ncow","created":1519549798692,"text":"（二）Java标识符命名约定","note":"见名知意\n驼峰命名法：首个单词以类名规则命名，其余单词首字母大写\n①类名规则：类名首字母大写，驼峰命名法\n②接口名规则：同类名，默认接口名前加I\n③方法名规则：方法名首字母小写；驼峰命名法\n④参数名规则：同方法名\n⑤包名规则：所有字母小写，用“.”分隔\n⑥常量名规则：所有字母大写，用“_”分隔"},"children":[]}]},{"data":{"id":"bjm3gl7r2q88","created":1519549835010,"text":"二、关键字","note":"关键字：Java赋予特殊含义的单词，51个 \n特点：全小写\n保留字：准备使用，还未使用（goto，const）","expandState":"expand"},"children":[]},{"data":{"id":"bjm3h8bejl4o","created":1519549885297,"text":"二、变量和常量","expandState":"collapse"},"children":[{"data":{"id":"bjm3hfs2tmw4","created":1519549901542,"text":"（一）常量","note":"1.常量：程序运行中值固定不变的量\n2.声明形式：final type CONST_NAME = value;\n（赋值一次，不能改变）\n3.常量分类：自定义常量&字面常量1,2,3...\n4.注意：final修饰的变量为常量，只能赋值一次。"},"children":[]},{"data":{"id":"bjm3hju4ci88","created":1519549910373,"text":"（二）变量","note":"1.变量：Java程序中状态可变的值，最基本的存储单元\n本质：内存中的一块连续的存储空间。\n要素：数据类型，变量名，变量值，变量作用域\n2.声明形式：type varName [=value];\n3.变量分类：按照变量类型：基本类型变量&引用类型变量\n按照变量声明位置：成员变量&局部变量\n4.注意：a.Java强类型语言，变量使用前必须先声明。\nb.Java局部变量必须初始化，成员变量有默认值。\n（变量初始化：变量第一次赋值）\n            c.变量的值，修改即被覆盖。"},"children":[]}]},{"data":{"id":"bjm3i9quoaw4","created":1519549966772,"text":"四、数据类型","expandState":"collapse"},"children":[{"data":{"id":"bjm3id5s294o","created":1519549974205,"text":"（一）常量数据类型","note":"①整型常量：二进制（0b/0B），八进制（0），十六进制（0x/0X），默认int型\n②浮点数常量：\tfloat单精度浮点数（*F/*f），double双精度浮点数（*D/*d），默认double型\n③字符常量：单字符‘a’\n④转义字符：\\n -- 换行，\\t -- 制表，\\r -- 回车，\\b -- 退格，\\’-- ‘，\\”-- “，\\\\ ---  \\ 。\n⑤字符串常量：“abc”\n⑥布尔常量：true，false。\n⑦null常量：null（表示对象的引用为空）"},"children":[]},{"data":{"id":"bjm3kfy4v8ws","created":1519550137001,"text":"（二）变量数据类型","note":"基本数据类型：\n1.整型：\tbyte（1B）(-128~127)\nshort（2B）\nint（4B）默认为int\nlong（8B）末位加*L/*l。\n2.浮点型：\tfloat（4B）末位加*F/*f。\ndouble（8B）默认为double。\n3.字符型：\tchar（2B）\n4.布尔型：\tboolean（1bit）：true，false。\n\n引用数据类型：类(class)，接口(interface)，数组，枚举，注解\n\n面试题：\n1.Java中八种基本数据类型？\nbyte，short，int，long，float，double，char，boolean\n2.String是否是一种数据类型？  \n不是，是String类名。\n3.在一个char中能否存储一个汉字？  \n能，一个char变量2个字节，一个汉字2个字节。"},"children":[]},{"data":{"id":"bjm3l27f8hkw","created":1519550185452,"text":"（三）数据类型转换","note":"自动转换：\t容量小的类型→容量大的类型，\n强制转换：\t容量大的类型→容量小的类型，精度损失或溢出。\n1.小容量足够，则正确；超出范围，则精度损失。\n2.byte，short，char之间不会相互转换，在计算时会自动转换为int类型进行计算。"},"children":[]},{"data":{"id":"bjm3ljg2nxss","created":1519550222980,"text":"（四）不同类型数据之间的运算结果的数据类型","note":"Java运算时，自动提升至最大数据类型。\n①整型byte，short，int运算 --> 运算结果int\n②整型int，long运算 --> 运算结果long\n③整型int，浮点型float运算 --> 运算结果float\n④浮点型之间运算 --> 运算结果double\n⑤字符型char = ASCII表int码\n⑥布尔型不能与其他任何类型进行运算"},"children":[]}]},{"data":{"id":"bjm3lt49ipcs","created":1519550244034,"text":"五、成员变量和局部变量","note":"成员变量\na.定义：声明在类内部，方法外部的变量\nb.作用域：类内有效。\nc.初始化：可不进行初始化，有默认值\n-整型默认值0\n-浮点型默认值0.0\n-char默认值‘\\u0000’\n（空格）\n-布尔型默认值false\n-String默认值null\nd.声明周期：随着对象的产生（消失）而产生（消失）\ne.内存分配：堆内存（new）\n\n局部变量\na.定义：声明在方法内部的变量（包括形参）\nb.作用域：方法内有效。\nc.初始化：必须初始化，无默认值\nd.声明周期：随着方法的调用（结束）而产生（结束）\ne.内存分配：栈内存\n\n在方法内，成员变量与局部变量同名，变量名访问的是局部变量；","expandState":"expand"},"children":[]},{"data":{"id":"bjm3qdb4s4ws","created":1519550601442,"text":"六、运算符","layout":null,"note":"※1.算术运算符：+，-，*，/ ，% ,++，--\n①i++：先执行后自增；\n②++i：先自增后执行；\n\n※2.逻辑运算符：&，|，^，!，&&，||，~，\n①逻辑与 &：&前false，&后表达式依旧执行。（按位与）\n②短路与 &&：&&前false，&&后表达式不执行。\n③逻辑或 |：|前true，|后表达式依旧执行。（按位或）\n④短路或 ||：||前true，||后表达式不执行。\n⑤异或 ^：同0，异1；异或三次交换值；\n       （m=m^n; n=m^n; m=m^n;）\n面试题：交换两个整数的值，不使用中间变量\n（1） x=x+y; y=x-y; x=x-y;\n（2）x=x*y; x=x/y; x=x/y;\n（3）m=m^n; n=m^n; m=m^n;\n※3.位运算符：<<，>>，>>>，~，&，|，^，（按位运算）\n    位运算是所有运算中，最快速高效的运算方法。\n①左移<<：乘；  x移n位，x乘2^n\n②右移>>：除；  x移n位，x除2^n\n③无符号右移>>>：补0\n面试题：使用最快速高效的方式，计算2e3。 位左移1<<3；\n4.赋值运算符：=，+=，-=，*=，/=，%=，\n        a+=b;   //a=a+b;\n5.条件运算符：a?b:c \n条件a==true，返回b；条件a==false，返回c；\n6.关系运算符：>，<，>=，<=，==，!=，\n\n赋值运算符，强转自动完成。\n%：忽略负号，求得余数，余数正负号由%前决定；","expandState":"expand"},"children":[]},{"data":{"id":"bjm3royynnk0","created":1519550705191,"text":"七、表达式","note":"表达式：符合一定规则的运算符和操作数\n表达式的值：运算结果\n表达式的类型：表达式的值的数据类型","expandState":"expand"},"children":[]},{"data":{"id":"bjm3rwwhbkoc","created":1519550722456,"text":"附、常用字符集","note":"ASCII码\t\nISO-8859-1：欧洲\nGBK/GB2313：国标\nUnicode：统一了世界上所有文字的编码\nUTF-8，UTF-16，UTF-32。\n（Java使用UTF-16,16位）","expandState":"expand"},"children":[]}]},{"data":{"id":"bjm3sdx9ie8k","created":1519550759508,"text":"流程控制","expandState":"collapse"},"children":[{"data":{"id":"bjm3sgpkls00","created":1519550765573,"text":"一、顺序控制语句","note":"在Java中的程序执行流程：\n从main方法开始执行，从main方法的方法体第一句开始，依次按语句的先后顺序，从上而下，逐句执行。\n\n附：\n●获取键入值\njava.util.Scanner sc = new java.util.Scanner(System.in);\nsc.nextInt();  //键入一个整型数据\nsc.next();  //键入一个字符串\n●延时输出：\ntry{\n\t\tThread.sleep(10);\n}//try\ncatch(Exception e){\n\te.printStackTrace();\n}//catch\n● ； //一条空语句","expandState":"expand"},"children":[]},{"data":{"id":"bjm3sntmt340","created":1519550781056,"text":"二、选择控制语句","note":"在程序执行过程中，在某些时候，我们代码的执行，需要满足一定的条件之后才去执行。","expandState":"collapse"},"children":[{"data":{"id":"bjm3tem1k6os","created":1519550839371,"text":"if语句","note":"1、if...\nif(条件/布尔表达式){\n语句1;\n}\n2、if...else...\nif(条件/布尔表达式){\n语句1;\n}else{\n语句2;\n}\n3、if...else if...\nif(条件/布尔表达式1){\n语句1;\n}else if(条件/布尔表达式2){\n语句2;\n}\n4、if...else if...else...\nif(条件/布尔表达式1){\n语句1;\n}else if(条件/布尔表达式2){\n语句2;\n}\n......\nelse{\n语句n;\n}\n5、嵌套\nif(条件/布尔表达式1){\nif(条件/布尔表达式2){\n语句2;\n}\n}\n●if针对的是boolean值进行判断；\n"},"children":[]},{"data":{"id":"bjm3tiph2u8g","created":1519550848285,"text":"switch语句","note":"switch(表达式){\ncase 常量1:\n语句1;\nbreak;\ncase 常量2:\n语句2;\nbreak;\n.......\ndefault:\n语句N+1;\nbreak;\n}\n\n※switch后的表达式的类型：\nbyte，short，int，char，\nJDK5引入 枚举；JDK7引入 String；\n\nswitch关键字：\n1.break：跳出当前switch。\n-无break会发生case穿透。\n2.default：case常量以外的值。\n-可以写在switch任意位置，\n-一般写在末尾，搭配break。\n3.case常量值不可以重复。\n4.case连续多个常量值对应相同语句，只需要在最后一个case后写上语句即可。\n\n●switch针对的是一些特定的，可列举的，有限的值。\n\n面试题：\n1.switch后的表达式的值类型可以是什么类型？\n2.switch后的可以是int？可以是long？可以是String？\t3.switch中的default必须出现在末位吗？ 不是，通常放在末尾。\n\nif与switch\n区别：\t1.if针对的是boolean值进行判断；\n2.switch针对的是一些特定的，可列举的，有限的值。\n联系：\t凡是switch都可用if表示，if不一定能用switch表达。"},"children":[]}]},{"data":{"id":"bjm3srmctvk0","created":1519550789324,"text":"三、循环控制语句","expandState":"collapse"},"children":[{"data":{"id":"bjm3vad3cp44","created":1519550986851,"text":"for循环","note":"for(初始化;条件;控制语句){\n循环体;\n}\n初始化变量作用域：\n仅for循环内"},"children":[]},{"data":{"id":"bjm3ve1nzq8k","created":1519550994867,"text":"while循环","note":"初始化;\nwhile(条件){\n循环体;\n控制语句;\n}\n\n初始化变量作用域：\n不仅限于while循环内"},"children":[]},{"data":{"id":"bjm3vgmtg14o","created":1519551000499,"text":"do...while循环","note":"初始化;\ndo{\n循环体\n}while(条件);\n先执行后判断\n\n初始化变量作用域：\n不仅限于while循环内"},"children":[]},{"data":{"id":"bjm3wa84w1kw","created":1519551064915,"text":"其他","note":"●for( System.out.println(\"此处执行一次\") ; ; System.out.println(\"此处循环执行\") ) {    }\n●死循环：循环条件永远为true。\n死循环利与弊：\n1.对于一个真实的应用程序，死循环应该规避；\n2.对于我们实际应用，要根据具体情况而定；\n有些特殊领域（eg.单片机）会需要死循环；\n\n\n面试题：\n1.for循环的三部分是什么？如果不存在是否可以不存在？不存在程序是否能正常执行？\n三部分：初始化语句，条件语句，控制语句\n        可以不存在，可以写在for语句的外面。\n        不存在可以正常执行，但是是死循环。\n2.利用没有循环体的for循环结构，输出HelloWorld\nfor( System.out.println(\"此处执行一次\") ; ; System.out.println(\"此处循环执行\") ) {      }\n3.输出九九乘法表\nfor(int i = 1;i < 10;i++){//行数\n\tfor(int j = 1;j <= i;j++){//列数\n\t\tSystem.out.print(j+\"*\"+i+\"=\"+(i*j)+\"\\t\");\n\t}\n\tSystem.out.println();//一行一换行\n}\n4.循环优化\nfor(int i = 0;i < 1000;i++)\n\t\t\tfor(int j = 0;j < 100;j++)\n\t\t\t\tfor(int k = 0;k < 10;k++)\n\t\t\t\t\ttestFunction(i,j,k);\t\t\t\n优化：时间（执行效率）、消耗资源\nfor(int i = 0;i < 10;i++)\n\t\t\tfor(int j = 0;j < 100;j++)\n\t\t\t\tfor(int k = 0;k < 1000;k++)\n\t\t\t\t\ttestFunction(i,j,k);\t\t"},"children":[]}]},{"data":{"id":"bjm3sv8yzsw0","created":1519550797221,"text":"四、跳转语句","note":"break：跳出当前循环，跳出一层循环；\ncontinue：跳出本次循环，进行下次循环；\nreturn：结束整个方法；\n※return语句必须是最后一句；\nreturn语句后不能再有其他语句；\n\n面试题：\n如何break跳出多重for循环：\n1.使用标签：\tbreak STOP;跳转至STOP:处（任意跳不推荐）\n2.使用标识符：\tflag=true;（跳出层循环条件 && flag）;\n不满足条件，则flag=false;break;","expandState":"expand"},"children":[]}]},{"data":{"id":"bjm3x1tsojk0","created":1519551124998,"text":"方法","expandState":"collapse"},"children":[{"data":{"id":"bjm3x6ullh4w","created":1519551135930,"text":"一、方法","note":"1.方法：完成特定功能的代码块\n2.方法声明形式：\n[访问修饰符] 返回值类型 方法名(形参列表){\n方法体;\n}\n●访问修饰符：public，protected，default，private，\n●静态修饰符static，最终修饰符final\n●返回值类型：基本数据类型，引用类型，void，\n●参数列表：参数个数，参数类型；\n3.方法调用：\n所有方法的执行，都必须在main方法中进行调用；\n非静态方法（无static修饰）可调用 静态方法/非静态方法；\n静态方法（有static修饰）只能调用 静态方法；\n①调用静态方法：\na. 类对象.方法名()；fun.test();\nb. 方法名直接调用；test();\n②调用非静态方法：\na.类对象.方法名()；fun.test();\n4.方法之间的关系：平行关系，相互调用；\n5.return关键字\n※return语句必须是最后一句，return;语句后不能再有其他语句；\n\n面试题：\n1.对于返回值为void的方法，能写return吗？ \n能，return;  即return 空；\n2.在return; 之后，能不能写其他语句？\n不能，return; 后是 无法访问的语句；","expandState":"expand"},"children":[]},{"data":{"id":"bjm3x82qh4gs","created":1519551138599,"text":"二、方法的重载（Overload）","note":"1.判断方法是否重载：\n①方法名相同\n②参数列表不同（参数个数不同，参数类型不同）\n（参数顺序不同（针对参数列表中存在不同类型数据））\n③返回值类型不同，不能界定方法是否重载；\n2.在一个类中，不能存在方法的定义形式完全一样的两个方法；","expandState":"expand"},"children":[]},{"data":{"id":"bjm3xdxteeos","created":1519551151362,"text":"三、方法的递归调用","note":"1.递归调用：方法自己调用自己\n2.结束条件：条件判断\n3.关键：递归式+结束条件；","expandState":"expand"},"children":[]},{"data":{"id":"bjm3yfm8l4gs","created":1519551233380,"text":"四、main方法","note":"1.main方法定义形式固定\n2.唯一可改变的是 形参名称args\n3.main方法的执行不需要显式调用，由JVM在类加载完成后，主动调用。","expandState":"expand"},"children":[]}]},{"data":{"id":"bjm3yu6hpe04","created":1519551265080,"text":"数组","expandState":"collapse"},"children":[{"data":{"id":"bjm3zoutze0o","created":1519551331855,"text":"一、一维数组","note":"1.数组：同种类型数据，有组织的存放于一定的内存空间里\n2.声明形式：\n    数据类型 数组名[] = new 数据类型[长度];  C++，C#\n数据类型[] 数组名 = new 数组类型[长度];  Java\nint[] array = new int[10];\n3.数组访问：\n数组名[数据下标]\n数组长度属性：arrayName.length \n4.数组默认值：\n①整型0，浮点型0.0，char型’\\u0000’，布尔false；\n②引用类型null；\n5.数组初始化：\n①动态初始化：先定义数组，再通过下标赋值\n数组名[下标] = 值；\n②静态初始化：定义时就直接赋值\n数组类型[] 数组名 = {1,2,3,4,5};   //值之间用,分隔\n数组类型[] 数组名 = new 数组类型[]{1,2,3,4,5};\n6.数组内存分配\n栈内存：系统自动分配释放；局部变量。\n堆内存：手动分配释放（new）；\n7.数组使用异常：\n①数组下标越界：ArrayIndexOutOfBoundsException\n②空指针异常：NullPointerException\narray = null，array指针不再指向堆内存中任何一块空间\n8.数组常用操作\n遍历：for循环，正序，逆序；\n查找：顺序查找\n排序：冒泡排序，选择排序，插入排序，快速排序\n9.参数传递\n①值传递：基本类型数据传递（传递数据）\n②引用传递：引用类型数据传递，参数指针传递；（传递地址）\n引用关系：栈内存存放地址，引用堆内存内数据\n引用变量值更改：return；\n10.数组工具类Arrays","expandState":"expand"},"children":[]},{"data":{"id":"bjm3zxpagjs4","created":1519551351111,"text":"二、二维数组","layout":null,"note":"1.声明形式：int[][] a = new int[row][column];\n2.二维数组初始化\n①动态初始化：\na[i][j] = value;\n②静态初始化：\nint[][] a = {{1,2,3,4 } , {1,2,3,4 } ,{1,2,3,4 } ,{1,2,3,4 } };\nint[][] a = new int[][]{ { 1,2,3,4 } , {1,2,3,4 } , {1,2,3,4 } };\n\n面试题：\n1.杨辉三角\n//杨辉三角\n\tpublic void pascalTriangle(int row){\n\t\tint[][] arr = new int[row][row];\n\t\tfor(int i = 0;i < arr.length; i++){\n\t\t\tfor(int j = 0; j <= i ; j++){\n\t\t\t\tarr[i][0] = 1;\n\t\t\t\tarr[i][i] = 1;\n\t\t\t}//for\n\t\t}//for\n\t\t//arr[i][j] = arr[i-1][j-1] + arr[i-1][j];\n\t\tfor(int i = 1;i < arr.length;i++){\n\t\t\tfor(int j = 1; j <= i;j++){\n\t\t\t\tarr[i][j] = arr[i-1][j-1] + arr[i-1][j];\n\t\t\t}//for\n\t\t}//for\n\t\t//三角输出\n\t\tfor(int i = 0;i < arr.length ;i++ ){\n\t\t\tfor(int j = 0; j <= i; j++){\n\t\t\t\tSystem.out.print(arr[i][j]+\"\\t\");\n\t\t\t}//for\n\t\t\tSystem.out.println();\n\t\t}//for\n\t\tSystem.out.println();\n\t}//pascalTriangle\n2.矩阵相乘\n//矩阵相乘\n\tpublic int[][] MatrixMultiplication(int[][] a,int[][] b){\n\t\tint[][] c = new int [a.length][b[0].length];\n\t\tfor(int i = 0;i < a.length;i++){//行\n\t\t\tfor(int j = 0;j < b[0].length;j++){//列\n\t\t\t\tfor(int k = 0;k < c.length;k++)\n\t\t\t\tc[i][j] = c[i][j] +a[i][k]*b[k][i];\n\t\t\t}\n\t\t}\n\t\treturn c;\n\t}","expandState":"expand"},"children":[]},{"data":{"id":"bjm40269gm0c","created":1519551360844,"text":"三、排序算法","layout":null,"note":"1.冒泡排序\n\t// 冒泡排序 ：大的沉底，小的上浮\n\tpublic void bubbleSort(int[] arr) {\n\t\tfor (int i = arr.length - 1; i > 0; i--) {\n\t\t\tfor (int j = 0; j < i; j++) {\n\t\t\t\tif (arr[j] > arr[j + 1]) {\n\t\t\t\t\tswap(arr, j, j + 1);\n\t\t\t\t}\n\t\t\t} // for\n\t\t} // for\n\t}// bubbleSort\n2.选择排序\n\t// 选择排序：缩小范围，两两比较\n\tpublic void selectSort(int[] arr) {\n\t\tfor (int i = 0; i < arr.length - 1; i++) {\n\t\t\tfor (int j = i + 1; j < arr.length; j++) {\n\t\t\t\tif (arr[i] > arr[j]) {\n\t\t\t\t\tswap(arr, i, j);\n\t\t\t\t} // if\n\t\t\t} // for\n\t\t} // for\n\t}// selectSort\n3.插入排序\n// 插入排序：多次比较，一次插入\n\tpublic void insertSort(int[] arr) {\n\t\tint j = 0;\n\t\tint key = 0;\n\t\tfor (int i = 1; i < arr.length; i++) {// 抽取新牌\n\t\t\tkey = arr[i];// 新牌\n\t\t\tfor (j = i - 1; j >= 0 && key < arr[j]; j--) {\n\t\t\t\tarr[j + 1] = arr[j];\n\t\t\t}\n\t\t\tarr[j + 1] = key;// 已经j--，必须j+1\n\t\t} // for\n\t}// insertSort\n\n\n4.快速排序\n/*\n\t * 快速排序：交换排序 \n\t * pivot：枢轴指针; pivotkey：枢轴值，\n\t * low：低指针， high：高指针，\n\t * partition(数组名称,起始位下标,末尾位下标); \n\t * qSort(数组名称,起始位下标,末尾位下标);\n\t */\n\t// 分区函数，返回枢轴指针\n\tpublic int partition(int[] arr, int low, int high) {\n\t\tint pivotkey = arr[low];// 设第一个元素为枢轴值\n\t\twhile (low < high) {\n\t\t\twhile (low < high && arr[high] >= pivotkey) {\n\t\t\t\thigh--;\n\t\t\t} // while\n\t\t\tarr[low] = arr[high];\n\t\t\twhile (low < high && arr[low] <= pivotkey) {\n\t\t\t\tlow++;\n\t\t\t} // while\n\t\t\tarr[high] = arr[low];\n\t\t} // while\n\t\tarr[low] = pivotkey;// 将枢轴值 给到 可覆盖区\n\t\treturn low;// 返回枢轴指针\n\t}// partition\n\n\t// 分区递归\n\tpublic void qSort(int[] arr, int low, int high) {\n\t\tif (low < high) {\n\t\t\tint pivot = partition(arr, low, high);// 枢轴指针\n\t\t\tqSort(arr, low, pivot - 1);// 前半部分\n\t\t\tqSort(arr, pivot + 1, high);// 后半部分\n\t\t}\n\t}// qSort\n\n\tpublic void quickSort(int[] arr) {\n\t\tqSort(arr, 0, arr.length - 1);\n\t}// quickSort","expandState":"expand"},"children":[]}]}]}]},{"data":{"id":"bjm41i5qt4gs","created":1519551474006,"text":"Java常用API","note":"API：应用程序编程接口；常用的功能的类的封装。\n用来实现常见的和通用的功能的类的封装。\n类库：API 根据实现的功能不同，划分为不同的集合，每个集合组成一个包，称为类库","expandState":"expand"},"children":[{"data":{"id":"bjm41scmgtko","created":1519551496189,"text":"一、Object类：根类","note":"1.Object是类层次所有类的根类/基类/父类/超类；Object的方法对于其他类都可直接使用。\n2.Object常用方法：\n①boolean equals() 比较两个对象的值是否相等；\n对象相等：equals()为true；\n②int hashCode() 返回该对象的哈希码值（唯一值）；\n对象相等：hashCode()相等；\n③String toString() 返回该对象的字符串表示；\n④void finalize() 当垃圾回收器确定不存在对该对象的更多引用时（垃圾回收时），由对象的垃圾回收器调用此方法。\na.对象的finalize方法不一定会被调用，即使是进程退出前\nb.发生gc()时一个对象的内存是否被释放取决于是否存在该对象的引用，该对象如果包含成员，那么对象成员遵循本条。\nc.对象里包含的对象成员，按声明顺序进行释放。\n// System.gc()：人为调用垃圾回收器\n注意：在实际开发中，不要去重写finalize()方法;也不要主动的去使用System.gc();","expandState":"expand"},"children":[]},{"data":{"id":"bjm42bik2g0g","created":1519551537907,"text":"二、String字符串","expandState":"collapse"},"children":[{"data":{"id":"bjm42mh84i04","created":1519551561771,"text":"（一）String字符串","note":"●String：字符串的抽象数据类型；提供了所有关于字符串的操作；\n●String本质：不可变的字符序列，字符数组；字符串常量；\n1.创建字符串：\n※所有字符串都是字符串常量，创建后值不可变；\n※相同的字符串在字符串常量池只有一份；常量池数据可共享\n①String str1 = “abc”; //str1指向字符串常量池\n②String str2 = new String(“abc”); //str2指向堆内存地址\n③String str3 = new String(); //str3 先指向堆内存\nstr3= “abc”; //将字符串常量池的地址赋给str3\nstr1 != str2，str1 == str3;\nstr1.equals(str2);  //true\nstr2.equals(str3);  //true\nstr1.equals(str3);  //true\n※==比较的是引用地址；equals比较的是对象内容；\n面试题：\n1.String str = new String(“abc”);\nString str = “abc”;\n创建了几个对象？  \n答：2个；堆内存一个，字符串常量区一个\nString str = new String(“abc”);\nString str = “abcd”;\n创建了几个对象？\n答：3个；堆内存一个，字符串常量区两个\n2.String str1 = “hello”;\nString str2 = “world”;\nString str3 = “helloworld”;\nString str4 = str1+str2;\nSystem.out.println(str3==str4);  //false 地址不同\nSystem.out.println(str3.equals(str4));  //true 内容相同\n3.Java中equals();与==的区别？\n==比较的是地址值；equals比较的是内容；\n\n\n\n2.String获取方法：\n①int length(); 返回字符串长度。\n②char charAt(int index); 返回指定索引的字符 \n③int indexOf(str1/int ch , [int i]); 返回指定字符的索引\n从第i位开始，第一次出现str1的索引。（ch为char字符的int值）\n④int lastIndexOf(str1/int ch , [int i]); 返回指定字符的索引\n从第i位开始，最后一次出现str1的索引。（ch为char字符的int值）\n⑤String substring(int start , [int end]); 字符串截取 [ )\n⑥String concat(str1 ); 字符串尾接\n3.String判断方法：\n①boolean equalsIgnoreCase(str); 比较字符串内容是否相同（忽略大小写）\n②boolean contains(str); 判断是否包含指定字符串str\n③boolean startsWith(str); 判断是否指定前缀str\n④boolean endsWith(str); 判断是否指定后缀str\n⑤boolean isEmpty(); 判断字符串是否为空“”\nstr = “”; //字符串为空\nstr = null ; //空指针，非有效引用，不指向内存空间\n\n4.String转换方法：\n①byte[] getBytes(); 把字符串转换为字节数组\n②char[] toCharArray(); 把字符串转换为字符数组\n③static String valueOf(char[] chs); 把字符数组转成字符串\n④static String valueOf(int i); 把int型数据转成字符串\n注意：String类的valueOf静态方法可以把任意类型的数据转成字符串。\n⑤String toLowerCase(); 把字符串转成小写\n⑥String toUpperCase(); 把字符串转成大写\n5.String其他方法：\n①String replace(oldstr,newstr); newstr替换oldstr\n  String replace(oldchar,newchar); newchar替换oldchar\n②String trim(); 忽略前导空格和尾部空格\n③int compareTo(str1); 按字典顺序比较两个字符串\n④int compareToIgnoreCase(str); 按字典顺序比较两个字符串（忽略大小写）","expandState":"expand"},"children":[]},{"data":{"id":"bjm43baa0lk4","created":1519551615771,"text":"（二）StringBuffer/StringBuilder","note":"●StringBuffer/StringBuilder：可变字符序列，通过某些方法调用可以改变字符序列的长度和内容。\n●StringBuffer本质：构造一个其中不带字符的字符串缓冲区。\n●StringBuffer()默认容量为 16 个字符。\n1.String和StringBuffer/StringBuilder\nString\t不可变的字符序列（空间浪费，资源利用率低）\nStringBuffer/\nStringBuilder\t可变的字符序列；通过某些方法调用可以改变字符序列的长度和内容。\n2.StringBuffer和StringBuilder\n\tStringBuffer\tStringBuilder\n区别：\t线程安全，效率低\t线程不安全，效率高\n使用\n场景：\ta.数据共享，需要保证线程的安全性和一致性；\ta.数据独享；\nb.在共享的时候，安全性要求不高；\n联系：\tStringBuilder是StringBuffer的兼容API。\n线程安全：两个线程共享一份数据时，为了保证数据的一致性，往往会在一个线程操作这份数据的时候，为当前数据加锁。\n面试题：\n1.StringBuffer(); 构造一个其中不带字符的字符串缓冲区，其初始容量为 16 个字符。\n2.StringBuffer和StringBuilder的区别？\n●StringBuffer常用方法\n①StringBuilder append(任意类型数据); 末端追加字符串\n②StringBuilder insert(int offset , 任意类型数据); 插入字符串\n③StringBuffer deleteCharAt(int index); 删除指定位置字符\n④StringBuffer delete(int start, int end); 删除子字符串\n⑤StringBuffer replace(int start,int end,str); 替换子字符串\n⑥String substring(int start,[int end]); 字符串截取\n⑦StringBuffer reverse(); 字符串反转（倒序）","expandState":"expand"},"children":[]}]},{"data":{"id":"bjm43tbx1o0s","created":1519551655052,"text":"（三）正则表达式","note":"1.常用的正则表达式：自行百度\n2.正则表达式的使用：\nString str = \"lanqiao@126.com\";\n// Pattern：类是正则表达式的编译表示形式。\nPattern p =Pattern.compile(\"^\\\\w+([-+.]\\\\w+)*@\\\\w+([-.]\\\\w+)*\\\\.\\\\w+([-.]\\\\w+)*$\");\n//Mathcer：类通过解释 Pattern 对字符序列执行匹配操作的引擎。\nMatcher m = p.matcher(str);\n//进行匹配的结果\nboolean flag = m.matches();","expandState":"expand"},"children":[]}]},{"data":{"id":"bjm44frj3koc","created":1519551703885,"text":"面向对象","note":"Java是一门纯粹的面向对象的编程语言。","expandState":"collapse"},"children":[{"data":{"id":"bjm44vghx8o4","created":1519551738046,"text":"面向对象的概念","note":"面向过程：结构化编程思想\n面向对象：事物高度抽象化\n面向对象的三大特性：封装，继承，多态。\n类：具有相同特征，行为和属性的多个对象的抽象。\n一组事物相关的属性和行为的集合\n类的属性：事物描述信息，成员变量表示。\n类的行为：事物功能信息，成员方法表示。\n类：抽象的（模型），对事物的抽象描述，属性和行为。\n对象：真实的（实例），类的具体实现。\n面向对象：从抽象到具体","expandState":"expand"},"children":[]},{"data":{"id":"bjm453pprrk8","created":1519551756018,"text":"类与对象","expandState":"collapse"},"children":[{"data":{"id":"bjm457ib4zcw","created":1519551764277,"text":"（一）类的定义","note":"修饰符 class 类名{\n//定义属性：成员变量\n变量修饰符  变量类型  变量名称；\n//定义行为：成员方法\n访问修饰符 返回值类型 方法名（形参列表）{\n}\n}\n成员变量与局部变量同名，方法内变量名访问的是局部变量；\n类的构成：代码块，构造方法，成员变量，成员方法；\n类内执行顺序：静态>构造，代码块>构造方法>成员方法；\n静态>初始化>构造器>成员方法；","expandState":"expand"},"children":[]},{"data":{"id":"bjm45fyqes8c","created":1519551782685,"text":"（二）对象的创建与使用","note":"1.对象的创建（类的实例化）：\n①类名 对象名称 = new 类名()；\n对象的内存分配：栈区，堆区，方法区（class区）\n2.对象的使用：\n①访问成员变量：对象引用.对象属性;\n②访问成员方法：对象引用.对象方法(实参列表)；\n3.匿名对象：\n①创建时没有名称，没有变量存储引用地址；\n②只能使用一次，栈内存中无匿名对象的引用地址；","expandState":"expand"},"children":[]},{"data":{"id":"bjm45nir6fsc","created":1519551799133,"text":"（三）类的封装","note":"封装：对外隐藏实现细节，提供公共访问方法\n①属性私有化：private成员属性（类内访问）；\n②公开访问方法：public get()、set()；","expandState":"expand"},"children":[]},{"data":{"id":"bjm45u24jows","created":1519551813365,"text":"（四）标准JavaBean（类）","note":"封装：属性私有化，对外公开get和set访问方法；\n无参构造，代参构造，\n重写toString( )；equals( )；hashCode( )；","expandState":"expand"},"children":[]}]},{"data":{"id":"bjm467bfaeww","created":1519551842225,"text":"构造方法（constructor）","note":"1.构造方法的特点：\n①构造方法的方法名与类名相同；\n②构造方法无返回值，无法return；\n2.构造方法的声明形式：\n访问修饰符 类名（形参列表）{ }\n3.构造方法的在何时使用：\n创建对象时由JVM自动调用；\n4.构造方法的重载：\n①对于未显式定义构造方法的类，系统会为类自动创建一个默认的无参构造方法；\n②对于已显式定义构造方法的类，系统不再提供默认无参构造方法；所以，最好再定义一个无参构造方法。\n5.构造方法的作用：\n①创建对象\n②对象初始化","expandState":"expand"},"children":[]},{"data":{"id":"bjm46ltangw8","created":1519551873781,"text":"代码块","note":"代码块作用：变量初始化；\n①普通代码块：\t在方法或语句中的{ }；先出现先执行；\n②构造代码块：\t对成员变量初始化；随对象创建而执行；\n③静态代码块：\t对静态变量初始化；随类加载而执行；","expandState":"expand"},"children":[]},{"data":{"id":"bjm46u6j92go","created":1519551891996,"text":"对象初始化","note":"创建对象时：\n①使用构造代码块初始化；\n②使用构造方法初始化；\n创建对象后：\t③调用set()初始化；","expandState":"expand"},"children":[]},{"data":{"id":"bjm476fcokgg","created":1519551918650,"text":"this关键字","note":"this代表本类当前对象；\nthis作用：\t\n①区分成员变量和局部变量：this.成员变量 = 局部变量\n②调用成员方法：this.成员方法\n③在构造方法中调用本类的其他构造方法：this(形参列表)\n（this( )必须在构造方法的第一行）","expandState":"expand"},"children":[]},{"data":{"id":"bjm489lff00s","created":1519552003912,"text":"static关键字","note":"static：创建独立于具体对象的域变量与方法；\nstatic可以修饰成员变量、方法、代码块、内部类；\n\nstatic使用：\n为特定域分配单一存储空间。\n变量或方法不与任何对象关联，该类所有对象共享。\n\nstatic随类加载而加载，new之前已存在；\n静态无法访问非静态；\nstatic特点：\n1.类相关，与对象无关；\n静态变量：类变量；静态方法：类方法；\n2.调用方式：\n直接调用：类名.属性; / 类名.方法();\n不需要创建对象，可直接使用；\n3.存储空间：存储于方法区中静态区；\n4.new之前执行\nstatic 减少代码开销\n使用static修饰的变量是属于当前类所有，所有对象所共有的\n使用static修饰的变量是随着类的加载而加载，成员变量是随着对象的创建而创建。\n静态方法注意事项：\n1.静态方法中，只能调用静态变量，不能使用非静态变量\n2.静态方法只能调用静态方法，不能调用非静态的方法\n3.非静态可以访问静态的，而静态的不能访问非静态的\n4.静态方法中不能使用this\n静态方法一般常用于工具类的方法\n思想：对于时间date进行格式化，工具类\n对静态变量初始化：\n1.声明变量时，\n2.静态代码块，\n\n静态代码块（执行一次）>构造代码块（随对象创建而执行）>无参构造方法（）>构造代码块>带参构造方法\n\n执行顺序：\n①静态（类加载执行）>非静态（new对象执行），\n②代码块>构造方法>成员\n\n调用静态变量：\n直接调用：变量名\n类名调用：类名.变量名\n\n静态变量，静态方法，静态代码块\n类加载\n1.加载main方法所在类，到方法区的class区；\n2.从main方法开始依次顺序执行，\n3.当使用到某一个类时，加载该类；\n4.加载类时扫描类中信息，为静态成员分配空间；\n5.类结束，释放静态成员；\n\n面试题：\n读程序，写结果；\n静态代码块（执行一次）>构造代码块（随对象创建而执行）>无参构造方法（）>构造代码块（随对象创建而执行）>带参构造方法\n\n静态成员与非静态成员区别：\n\t静态成员\t非静态成员\n1.内存分配：\t随类加载而加载\t随对象产生而产生\n2.调用方式：\t类名调用\t对象调用\n3.生命周期：\t与类相关\t与对象相关\n4.共享方式：\t全类共享\t当前对象独享\n\n静态优点：\n1.一个静态属性在堆内存只能存在一个，即大家可以共享该属性值。 \n2.如果一个对象数组中其中的某个属性大家都是相同的，即可以使用静态，这样可以节省内存空间。 \n3.静态一旦创建，生命周期就会从创建开始到该程序结束才会死亡。 \n4.静态依赖于类，而不是对象。 \nMain方法：\npublic：访问权限足够大\nstatic：对象产生之前，就要调用；","expandState":"expand"},"children":[]},{"data":{"id":"bjm4971o5g08","created":1519552076728,"text":"单例模式（Singleton）","note":"单例模式：使类始终保持只有一个实例。\n①静态创建对象\n②私有化构造方法\n③公开提供静态获取实例方法\n1.懒汉式：\n若对象引用==null：new一个对象；\n若对象引用！=null：直接返回已有对象地址； \npublic class Singletonif {\n\t// 静态实例化\n\tprivate static Singletonif s = null;\n\t// 私有化构造方法\n\tprivate Singletonif() {\n\t}\n\t// 公开提供静态获取实例的方法\n\tpublic static Singletonif getInstance() {\n\t\tif (s == null) {\n\t\t\ts = new Singletonif();\n\t\t}\n\t\treturn s;\n\t}\n}\n\n2.饿汉式：\npublic class Singletonfinal {\n\t// 静态 final 实例化\n\tprivate static final Singletonfinal s = new Singletonfinal();\n\t// 私有化构造方法\n\tprivate Singletonfinal() {\n\t}\n\t// 公开提供静态获取实例的方法\n\tpublic static Singletonfinal getInstance() {\n\t\treturn s;\n\t}\n}","expandState":"expand"},"children":[]},{"data":{"id":"bjm4a1z7yn4k","created":1519552144060,"text":"继承（extends）","note":"父类/超类\n子类/派生类：父类的拓展\nJava继承的特点：\nJava继承都是单继承，不允许多继承，但可以多层继承。\n单继承：一个类只能有一个父类；但是一个父类可以有多个子类\n子类可以继承父类那些成员：\n1.非私有（private）成员属性；\n区分子类和父类的同名的成员属性：\nsuper：代表父类当前对象；\n \t2.构造方法：\n不能继承，可以调用\nsuper() 调用父类构造方法；（必须出现在第一句）\n3.构造代码块：\n父类构造代码块-->父类构造方法-->子类构造代码块-->子类构造方法\n4.静态代码块\n静态代码块和静态方法在类加载时即执行；\n5.成员方法\n继承非私有方法；\n先调用子类方法，后调用父类方法，\n\n\n","expandState":"collapse"},"children":[{"data":{"id":"bjm4aezibt44","created":1519552172376,"text":"方法的重写（Override）","note":"重写：子类重写父类的方法；\n重写条件：\n1.继承关系\n2.方法声明形式完全相同\n3.访问修饰符：子类重写方法不能比父类方法严格\n重写作用：\n方法的扩展或重新实现；\n\n6.静态方法\n静态方法形式上的继承，本质不是继承；\n静态方法不能重写；\n面试题：\n父类{静态代码块，构造代码块，构造方法}\n子类{静态代码块，构造代码块，构造方法}\n创建子类对象：①静态>非静态，②代码块>构造方法>成员\n\nnew时，先调用父类构造方法；\n\n继承是两个类\n继承的好处\n1.提高了代码的复用性；\n多个类相同的成员可以放到同一个类中\n2.提高了代码的维护性；\n如果功能的代码需要修改，修改一处即可\n3.使类与类之间产生了关系，继承是多态的前提；\n其实这也是继承的一个弊端：类的耦合性很强\n子类是父类的扩展，不是简单的复制\t\n\nsuper关键字","expandState":"expand"},"children":[]},{"data":{"id":"bjm4ay5yni0w","created":1519552214125,"text":"final关键字","note":"final：最终修饰符，终态，不可改变；\nfinal类：不能被继承（太监类）；\nfinal方法：不能被重写；\nfinal变量：只能赋值一次；\nfinal引用类型：地址不能被改变；","expandState":"expand"},"children":[]},{"data":{"id":"bjm4bj3ts4oo","created":1519552259708,"text":"类与类之间的关系","note":"类与类之间的关系：\n继承，\n依赖：一个类作为另一个类的参数出现\n类之间存在着整体和部分的关系\n聚合：另一个类的存在与否不会影响到当前类的完整性\n组合：另一个类的存在与否会直接影响到当前类的完整性\n\n组合模式：树","expandState":"expand"},"children":[]}]},{"data":{"id":"bjm4bw3a9m8s","created":1519552287973,"text":"多态","note":"多态：\n父类的引用指向子类的对象\n多态的条件：\n类之间存在继承关系；\n必须有方法的重写；\n\nA a = new B();\n在A类中检测，在B类中调用；\n\n类型转换：\n向上转型：自动转换，父类的引用指向子类的对象\n向下转型：强制转换，还原为子类；\n（向下转型非原子类会失败）\n类型判断：\nboolean 对象instanceof类：判断该对象是否属于目标类；\n多态访问类的成员：\n成员变量：编译看左边，运行看左边\n成员方法：编译看左边，运行看右边\n静态变量/方法：编译看左边，运行看左边","expandState":"expand"},"children":[]},{"data":{"id":"bjm4cdn0be8s","created":1519552326171,"text":"抽象（abstract）","expandState":"collapse"},"children":[{"data":{"id":"bjm4ck3ycg84","created":1519552340257,"text":"抽象类","note":"意义：被子类继承（extends）；\n①不能被实例化；用来被子类继承\n②存在构造方法；子类可以访问抽象成员\n③不能被final修饰；","expandState":"expand"},"children":[]},{"data":{"id":"bjm4cmzjxcoc","created":1519552346521,"text":"抽象方法","note":"意义：被非抽象子类重写（@Override）；\n①只提供方法声明，不进行方法实现；\n②不能被private，static，final修饰；\n③只存在于抽象类中（抽象类中不一定存在抽象方法）\n非抽象子类必须重写抽象父类中所有抽象方法\n抽象类不一定有抽象方法，存在抽象方法的类一定是抽象类；\n\n面试题：\n1.抽象方法能用private修饰吗？\n不能，private方法不能被重写；\n2.抽象方法抽象类能用final修饰吗？\n不能，final方法不能被重写，final类不能被继承\n3.抽象方法能用static修饰吗？\n不能，static方法不能被重写。","expandState":"expand"},"children":[]}]},{"data":{"id":"bjm4d1bvg2ok","created":1519552377741,"text":"模板设计模式","note":"由抽象衍生的设计模式；\n①把通用的功能写成final的；\n②把变化的功能写成abstract的；便于子类重写。","expandState":"expand"},"children":[]},{"data":{"id":"bjm4d8tnlao8","created":1519552394054,"text":"接口（interface）","note":"接口（interface）：一种标准和规范；（类似多继承）\n接口的意义：被实现（implements）；\n接口的组成：\n接口常量：默认public static final修饰变量；\n接口中只存在静态常量；\n接口方法：只能用abstract，public，default，static修饰方法\n接口中只存在抽象方法；\n接口的使用：\n接口名称 引用变量 = new 实现类（）；\n多态的体现：接口的引用指向实现类的对象；\n接口的特点：\n①接口不能实例化；\n②接口没有构造方法；\n③多继承，多实现；\n接口可以继承接口；接口的继承是多继承；\n接口的实现类可以多实现\n接口和类区别：\n1.接口不能实例化；\n2.接口中没有构造方法\n\n类与类：继承；单继承，可多层继承；\n类与接口：实现；多实现；\n接口与接口：继承；多继承；\n\n抽象类：“is a”通用\n接口：“like a”扩展\n\n接口与抽象类：\n联系：两者都不能被实例化\n区别：①抽象类存在构造方法；接口中不存在构造方法；\n②抽象类是用来继承的；接口是用来实现的；","expandState":"expand"},"children":[]},{"data":{"id":"bjm4djswm6g4","created":1519552417953,"text":"内部类","note":"内部类：定义在类内部的类；\n内部类的意义：服务于外部类；","expandState":"collapse"},"children":[{"data":{"id":"bjm4e20voi88","created":1519552457617,"text":"成员内部类","note":"成员内部类\n①声明位置：类内部，方法外部\n②作用域：类内\n③实例化：通过外部类对象访问内部类\n外部类.内部类 对象 = new 外部类().new 内部类();\n④class文件：外部类.class\n外部类$内部类.class\n⑤类的构成：与普通类相同\n⑥访问限制：可直接访问外部类任意成员；\n一般使用private修饰，服务于外部类；","expandState":"expand"},"children":[]},{"data":{"id":"bjm4e9x2ix44","created":1519552474801,"text":"方法内部类","note":"方法内部类\n①声明位置：方法内部\n②作用域：方法内\n③实例化：方法内实例化\n④class文件：外部类.class\n外部类$1内部类class\n⑤类的构成：与普通类相同\n⑥访问限制：只能使用方法的final局部变量；jdk8会自动为局部变量添加final修饰；","expandState":"expand"},"children":[]}]},{"data":{"id":"bjm4fvw48gg8","created":1519552600997,"text":"包","note":"对类进行分包管理（文件夹）；\n包的命名规则：公司域名的反写+模块名称\n包的关键字：package\n全类名：包名.类名\nJar包：\n1.使用eclipse的export功能\n2.第三方工具：fatjar\n3.Jar文件运行：java -jar 类名.jar\n导包：\nJava 中的类是分包管理的，你要使用的类和当前类不在同一包下，需要导包。\nimport 包名.类名；\nimport 包名.*；//通配符*，将包下所有类都导入，慎用。\n在Java中除lang包下的类不用导包，其他都得导入\n访问控制：\npublic，protected，默认，private，","expandState":"expand"},"children":[]}]}]},{"data":{"id":"bjm30fy5m7co","created":1519548569719,"text":"Java高级","layout":null,"expandState":"collapse"},"children":[{"data":{"id":"bjm4ghp4l7cc","created":1519552648463,"text":"数据结构","note":"（一）基本概念：\n①数据：描述客观事物的符号；  数值型数据/非数值型数据\n②数据元素：数据的基本单位，（结点/记录）；\n③数据项：有独立含义的最小单位；（属性/字段/域）；\n数据-->数据元素-->数据项（field）\n\n（二）数据结构：数据之间的关系；\n逻辑结构：线性：\t线性：一对一； 线性表，栈，队列，串\t\n非线性：集合：\n树：一对多；\n图：多对多；\n存储结构：顺序存储结构：（数组）元素物理地址连续\n链式存储结构：（指针）元素指针指向下个元素地址\n\n（三）数据运算：\n插入，删除，修改，查找，排序","expandState":"collapse"},"children":[{"data":{"id":"bjm4hokwoeo8","created":1519552741810,"text":"线性表","note":"初始化，取值，查找，插入，删除；\n\n顺序表的优缺点：\n优点：元素存储密度大；\n可随机存取任一元素；\n缺点：不易于进行插入删除操作\n浪费存储空间\n静态存储，无法自动扩充；\n\n单链表：存储的物理地址不一定相邻；","expandState":"collapse"},"children":[{"data":{"id":"bjm4kidphggk","created":1519552963406,"text":"顺序表","expandState":"expand"},"children":[]},{"data":{"id":"bjm4kkph9y8k","created":1519552968472,"text":"单链表","expandState":"expand"},"children":[]},{"data":{"id":"bjm4kmwkeowk","created":1519552973254,"text":"双向链表","expandState":"expand"},"children":[]},{"data":{"id":"bjm4kr3myio0","created":1519552982388,"text":"循环链表","expandState":"expand"},"children":[]}]},{"data":{"id":"bjm4kub3v3ks","created":1519552989370,"text":"栈","note":"先进后出","expandState":"expand"},"children":[]},{"data":{"id":"bjm4l5l6fuw4","created":1519553013924,"text":"队列","note":"先进先出","expandState":"expand"},"children":[]},{"data":{"id":"bjm4lb7yz5s0","created":1519553026186,"text":"树","expandState":"collapse"},"children":[{"data":{"id":"bjm4lg3jvt44","created":1519553036803,"text":"二叉树","expandState":"expand"},"children":[]}]},{"data":{"id":"bjm4ld1hiagc","created":1519553030147,"text":"图","expandState":"expand"},"children":[]}]},{"data":{"id":"bjm4gmzyeo84","created":1519552660002,"text":"集合与泛型","expandState":"collapse"},"children":[{"data":{"id":"bjm4loxn9egc","created":1519553056037,"text":"集合概述","note":"集合的产生：为保存数目不确定的对象，解决数组长度固定的问题；\n集合类：可以存储任意类型的对象，并且长度可变的类；\n集合的分类：\n按存储结构分类：\nCollection 单列集合\nList 有序（插入顺序），集合元素可重复的集合\n实现：ArrayList，Vector，LinkedList；\nSet 无序（插入顺序），集合元素不可重复的集合\n实现：HashSet，TreeSet；\n自然排序：Comparable接口的排序规则；\nMap 双列集合，具有键值映射关系\n实现：HashTable，HashMap，\nLinkedHashMap，TreeMap，\n集合的特点：\n①只能存储引用类型；\n②长度可变，不受限制；\n数组与集合的区别：\n数组：长度固定，可存储基本数据类型和引用类型；\n获取长度：数组length属性\n遍历：for循环\n集合：长度可变，只能存储引用类型；\n获取长度：集合size()； \n   遍历：for循环；迭代器Iterator遍历；增强for循环","expandState":"expand"},"children":[]},{"data":{"id":"bjm4lyoavtc8","created":1519553077239,"text":"Collection接口","note":"子接口：List，Set，\n已知实现类：ArrayList，Vector，LinkedList，HashSet，TreeSet","expandState":"collapse"},"children":[{"data":{"id":"bjm4mefgzhcg","created":1519553111534,"text":"Iterator迭代器接口","note":"迭代器Iterator：遍历Collection中的元素；\nboolean hasNext( ); 判断是否有下一个元素；\n （指针指向输出元素的下一个）；\n实际使用中，遍历常用while(hasNext()){ }；\nnext(); 移动指针指向下一个元素，并返回元素的值；\n\nListiterator：\n正向遍历，反向遍历\n修改的是迭代器中的集合\n注意事项：\n不能在迭代的同时，改变集合的结构，不能向集合中插入删除元素。否则会出现ConcurrentModificationException异常；\n解决方案：\n①使用迭代器进行迭代，并使用迭代器（ListIterator）修改；\n②使用for循环、增强for循环进行遍历；\n增强for循环：遍历数组与集合；\nfor(元素类型 变量：容器对象){  }","expandState":"expand"},"children":[]},{"data":{"id":"bjm4mnk0zy80","created":1519553131401,"text":"List接口","note":"List接口：有序（插入顺序），元素可重复的Collection；\n已知实现类：ArrayList，Vector，LinkedList；\n\n集合遍历修改：\n当集合使用迭代器迭代的时候，不允许向原集合添加元素，但可以原集合。\n如何解决：\n1.使用迭代器get( )元素添加。\n2.不使用迭代器，使用for循环遍历。\n\nList常用实现类：\nArrayList：\n①基于长度可变的数组实现；\n②允许多个null值存在；\n③不同步（线程不安全）\n数组：元素个数确定的情况下；\nArrayList：元素个数不确定的情况下；\nVector：（已过时）\n①基于长度可变的数组实现\n②允许多个null值存在；\n③同步的（线程安全的）\n不常用；\nArrayList与Vector的区别：是否同步；\nLinkedList：\n①基于双向链表实现\n②允许多个null值存在\n③不同步（线程不安全）\n实现了链表，栈，队列等的操作。\n\n数组：元素个数确定的情况下；\nArrayList：元素个数不确定的情况下；\n\nList在实际开发中的应用：\n1.如何选择List接口不同实现？\nArrayList：数组实现（取值查询效率高），不同步\nVector：数组实现（取值查询效率高），同步，不常用；\nLinkedList：链表实现（插入删除效率高），\n2.使用List接口的多态还是使用具体的对象？\n在实际开发中，使用List接口的多态更多；\n3.如果不考虑性能问题，三个实现那个使用更多？\n在实际开发中，一般使用List list = new ArrayList；","expandState":"expand"},"children":[]},{"data":{"id":"bjm4mysktlc8","created":1519553155862,"text":"Set接口","note":"数学意义上的集合：互异性，无序性，确定性；\nSet接口：无序，元素不重复的Collection；\n重复判断依据：s1.equals(s2) == true；\n当add存入时，即进行重复判断；\nSet典型实现类：HashSet，TreeSet；\n\nHashSet：\n①基于HashMap实现，使用的是HashMap中的key；\n不保证Set迭代顺序恒久不变；\n②允许一个null值存在；\n③线程不安全；\n\nTreeSet：\n①基于TreeMap实现，使用的是TreeMap中的key；\n默认使用Comparable进行自然排序\n②可进行自然排序、定制排序；\n③线程不安全\n\n自然排序：\n由元素类型决定排序方式，使用内部比较器：实现Comparable接口，实现compareTo方法；\n已实现Comparable接口，重写comareTo方法：\n①基本数据类型的包装类：\n==：return 0；\n>：return 正整数；\n<：return 负整数；\n②字符串比较：按字典顺序（Unicode）；\n\n定制排序：\n由容器决定排序方式，使用容器比较器：创建一个比较器，实现Comparator接口，实现compare方法；\n比较器的创建：\n①自定义外部类\n②写一个内部类\n③匿名内部类","expandState":"expand"},"children":[]}]},{"data":{"id":"bjm4nh8eldkw","created":1519553196001,"text":"Map接口","note":"Map接口：双列，无序（存取顺序），以键值对形式存储；\n实现：HashTable，HashMap，TreeMap\nAbstractMap --> HashMap --> LinkedHashMap\nSortedMap --> TreeMap\nHashTable\n\n①以键值对形式存储\n②Key不允许重复\n③键值映射关系\n\nMap与Collection的区别：\n\nMapEntry：一对键值对<key，value>；","expandState":"collapse"},"children":[{"data":{"id":"bjm4nqrri48w","created":1519553216763,"text":"HashMap","note":"基于HashTable存储；\n基于哈希表、Hash桶数组是实现；\nHash桶数组结构：数组+链表+红黑树；\n数组元素存储 一个链表/红黑树 的hashCode；\n提高遍历效率：JDK8后引入红黑树；\n链表长度>8，转化为红黑树；\n\nHashMap：线程不安全，不支持并发操作；\nConcurrentHashMap：线程安全，支持并发操作；\n\n1.put操作：\n流程图：\n①判断数组是否为空； \n②key是否存在；key存在，直接覆盖value；\n\n2.扩容机制：\n扩容：16x0.75=12时扩容；\n扩容极其耗性能；\n扩容优化：估算，初始化容量；\n\n面试题：\nArrayList的扩容实现和HashMap的扩容的实现的对比？\n\nfail-fast机制：不一定触发；\nConcurrentModificationException；\n\nHashMap最重要，最常用的Map","expandState":"expand"},"children":[]},{"data":{"id":"bjm4ofk0u4o4","created":1519553270714,"text":"TreeMap","note":"基于红黑树实现；\nTreeMap：对key进行自然排序的<key，value>集合；\n数据结构：红黑树；查询速率高；\n不允许null键，允许null值；\n一般在对key排序时，使用TreeMap；","expandState":"expand"},"children":[]},{"data":{"id":"bjm4omwv07sc","created":1519553286728,"text":"HashTable","note":"基于哈希表实现；线程安全的；不允许null键null值；\n古老，过时，不常使用；\n面试题：\nHashTable与HashMap的区别：\n①Hashtable 是一个古老的 Map 实现类，不建议使用\n②Hashtable 是一个线程安全的 Map 实现，但 HashMap 是线程不安全的。\n③Hashtable 不允许使用 null 作为 key 和 value，而 HashMap 可以\n④与 HashSet 集合不能保证元素的顺序一样，Hashtable 、HashMap 也不能保证其中 key-value 对的顺序\n⑤Hashtable 、HashMap 判断两个 Key 相等的标准是：两个 Key 通过 equals 方法返回 true，hashCode 值也相等。\n⑥Hashtable 、HashMap 判断两个 Value相等的标准是：两个 Value 通过 equals 方法返回 true","expandState":"expand"},"children":[]}]},{"data":{"id":"bjm4ox46yyw4","created":1519553308939,"text":"Collections工具类","expandState":"expand"},"children":[]},{"data":{"id":"bjm4p7mo920c","created":1519553331825,"text":"泛型","note":"为什么使用泛型：集合元素取出时，自动转化成Object类型；\n泛型：不确定集合元素类型时，集合元素类型的参数化；\n<参数化类型>，\n常用泛型形式：<E>，<T>，<K>，<V>\nJDK7泛型的新特点：后面的<>可省略；\nList<参数化类型> list = new ArrayList<参数化类型>();\n集合若不定义泛型，默认Object类型；\n泛型擦除：泛型只在编译阶段有效，运行阶段不存在了；\n泛型类：集合元素类型是泛型；\n泛型接口：访问修饰符 interface 接口名<T>{  }\n泛型方法：访问修饰符 <T> T 方法名称 （参数列表）{  }\n泛型通配符：\n<? extends T> 下限，只能使用T和T的子类；\n<? super T> 上限，只能使用T和T的父类；\n<?> 未知类型，默认Object类型；","expandState":"expand"},"children":[]},{"data":{"id":"bjm4pglpdmo0","created":1519553351357,"text":"可变参数","font-weight":"bold","note":"可变参数：在定义方法时，不确定传入参数的个数\n方法形参：（参数类型 ... 容器）；\n可变参数的用法：跟数组相同，位于参数列表的末尾；","expandState":"expand"},"children":[]}]},{"data":{"id":"bjm4gqnbzaos","created":1519552667946,"text":"异常","expandState":"collapse"},"children":[{"data":{"id":"bjm8p7aygwwg","created":1519564615556,"text":"异常概述","note":"异常：程序编译和运行阶段，发生的不正常现象，称为异常。\n已知异常：\n①数组下标越界：ArrayIndexOutOfBoundsException\n②空指针异常：NullPointerException\n③类型转换异常：ClassCastException\n④不正当修改异常：ConcurrentModificationException\n⑤解析异常：ParseException","expandState":"expand"},"children":[]},{"data":{"id":"bjm8pkuc7nk0","created":1519564645026,"text":"异常分类","note":"Throwable\nError：指系统发生错误，无法处理\n①JVM崩溃VirtualMachineError\n②内存溢出OutOfMemoryError\nException：\n编译期异常：Checked Exception\nParseException\n运行时异常：Runtime Exception\n（Unchecked Exception）\njava.lang.IndexOutOfBoundsException\n\t\tjava.lang.NullPointerException\njava.lang.ClassCastException\njava.lang.ArithmeticException\n异常区分：\n编译期异常：Exception的子类\n运行时异常：Exception-->RuntimeException的子类","expandState":"expand"},"children":[]},{"data":{"id":"bjm8psguatk4","created":1519564661624,"text":"异常处理","expandState":"collapse"},"children":[{"data":{"id":"bjm8pw07iawo","created":1519564669325,"text":"基本异常处理","note":"（一）默认处理：JVM自动处理，输出异常，结束程序运行。\n（二）捕获、抛出机制\n一般情况下，我们需要对异常做出相应的处理（抓抛模型）；\n1.抛出异常：throws 对应异常类型；\n方法声明处抛出；\n抛给调用者，调用者可以选择 处理/抛出，直至抛给JVM默认处理；\n2.捕获异常：\ntry{\n可能发生异常的代码；\n}catch( 异常类型 相应类型变量 ){\n异常处理；（异常发生时执行）\n}finally{\n必然执行；（无论异常是否发生，必然执行）\n}\ntry{}catch(){}...\ntry{}catch(){}finally{}\ntry{}catch(){}...catch(){}finally{}\ntry{}finally{}\nJDK7新特性：平级异常类型可并列或\ntry{}catch(异常类型 | 异常类型 | 异常类型 | 变量){}\n不能越级并列（子类与父类不可并列）\n常与instanceof连用。","expandState":"expand"},"children":[]},{"data":{"id":"bjm8q5dk9soc","created":1519564689724,"text":"多异常处理","note":"①多catch连用\n②catch异常类型或并列\n低级异常处于catch上层\n高级异常处于catch下层\n\n\n获取异常信息：\nvoid printStackTrace(); 打印异常堆栈信息；\ngetMessage(); 返回异常信息字符串；\n\n\n主动抛出异常：\n方法内部，throw new 异常类( )；\n①new Exception(异常信息); 主动抛出编译期异常\n②new RuntimeException(异常信息); 主动抛出运行时异常\n\nthrows与throw的区别：\n①声明位置：\nthrows方法声明处抛出；\nthrow方法内抛出；\n②抛出目标：\nthrows抛出异常类型；\nthrow抛出异常对象；\n③抛出异常数量：\nthrows抛出多个异常；\nthrow抛出一个异常；\n④异常发生：\nthrows可能发生异常，不一定发生；\nthrow一定抛出一个异常对象；\n\n异常处理策略：\n编译期异常：必须处理，否则程序会报错，无法执行；\n运行时异常：可以不处理，可通过代码逻辑修改避免；\n处理策略：\n如果清楚异常如何处理，自己处理，无需暴露；\n如果不清楚异常如何处理，不作处理，抛给方法调用者，告知异常的存在；","expandState":"expand"},"children":[]}]},{"data":{"id":"bjm8qf1lw5s8","created":1519564710769,"text":"finally语句","note":"①程序连接数据库时，无论访问是否成功，都应该将链接释放\n②在I/O操作中，最终都需要将I/O流关闭；\n面试题\ntry块中有return语句，finally语句还会执行吗？在什么时候执行？\n异常未发生，finally一定会执行；finally先于return执行；\n异常发生，finally一定会执行，return不执行；\n异常发生后，try块内异常之后的语句不执行；","expandState":"expand"},"children":[]},{"data":{"id":"bjm8r8i9zz4k","created":1519564774903,"text":"自定义异常类","note":"自定义编译期异常：\n自定义编译期异常类 extends Exception\n无参构造：super();\n有参构造：super(str);\npublic class MyException extends Exception {\n\tpublic MyException() {\n\t\tsuper();\n\t}\n\tpublic MyException(String str) {\n\t\t// 异常处理信息\n\t\tsuper(str);\n\t}\n}\n\n自定义运行时异常：\n自定义异常类 extends RuntimeException\n无参构造：super();\n有参构造：super(str);\npublic class MyRuntimeException extends RuntimeException {\n\tpublic MyRuntimeException() {\n\t\tsuper();\n\t}\n\tpublic MyRuntimeException(String str) {\n\t\t// 异常处理信息\n\t\tsuper(str);\n\t}\n}","expandState":"expand"},"children":[]}]},{"data":{"id":"bjm4gtnniuww","created":1519552674496,"text":"IO与NIO","expandState":"expand","note":"IO：输入输出（input/output）  java.io包"},"children":[{"data":{"id":"bjm8rt40pfcw","created":1519564819754,"text":"File类","note":"File类：文件/目录的路径名的抽象表示形式；与OS无关；\n路径表示：\n绝对路径：相对于根目录，从根目录到文件/目录的表示\n相对路径：相对于当前位置，当前工程下的文件/目录\n●规避不同OS的路径分隔符：File.separator；","expandState":"collapse"},"children":[{"data":{"id":"bjm8s5xo4m8g","created":1519564847668,"text":"（一）File类构造方法","note":"public File(String pathname)；\npublic File(String parent,String child)；\npublic File(File parent,String child)；","expandState":"expand"},"children":[]},{"data":{"id":"bjm8sdntdi0c","created":1519564864486,"text":"（二）File类常用方法","note":"1.创建功能\npublic boolean createNewFile()；\npublic boolean mkdir()；\npublic boolean mkdirs()；\n\n2.删除功能\npublic boolean delete()\n可删除文件、空目录； （删除目录必须保证目录为空）\n\n3.重命名功能（另存为）\npublic boolean renameTo(File dest)\n将当前文件重命名并剪切到目标目录中\n\n4.判断功能\npublic boolean isDirectory()\npublic boolean isFile()\npublic boolean exists()\npublic boolean canRead()\npublic boolean canWrite()\npublic boolean isHidden()\n\n5.基本获取功能\npublic String getAbsolutePath()\npublic String getPath()\npublic String getName()\npublic long length()\npublic long lastModified()\n\n6.高级获取功能\npublic String[] list();\npublic File[] listFiles();","expandState":"expand"},"children":[]}]},{"data":{"id":"bjm8swvgcf4g","created":1519564906307,"text":"IO流","expandState":"collapse"},"children":[{"data":{"id":"bjm8t2xnkmww","created":1519564919501,"text":"一、IO流概述","note":"在Java中，对于数据的输入输出操作都是以“流”的方式进行。\n流是程序与文件之间数据交换的抽象；\n●输入：将数据从磁盘或外界媒质 读入到程序中时；\n●输出：将数据从程序中写到外部存储设备时；","expandState":"expand"},"children":[]},{"data":{"id":"bjm8t5m0zbsc","created":1519564925328,"text":"二、IO流分类","note":"①按流的方向分：输入流，输出流；\n②按文件组成单元分：字节流，字符流；\na.字节文件：文本、图片、音频、视频；\nb.字符文件：纯文本文档（.txt）；\n③按照流是否直接与特定的地方(如磁盘、内存、设备等)相连分：\na.节点流：可以从或向一个特定的地方（节点）读写数据；例如：InputStream；OutputStream；Reader；Writer；\nb.处理流：是对一个已存在的流的连接和封装，通过所封装的流的功能调用实现数据读写。例如：BufferedInputStrean；\n\njava.io\t输入流\t输出流\n字节流\tInputStream\tOutputStream\n字符流\tReader\tWriter","expandState":"expand"},"children":[]},{"data":{"id":"bjm8t8z2qdc0","created":1519564932648,"text":"三、字节流","note":"字节流：二进制数据；文本、图片、音频、视频\n适用于操作图片、音频、视频；","expandState":"expand"},"children":[{"data":{"id":"bjm8ub0h3xss","created":1519565015450,"text":"1.字节输入流InputStream","note":"字节输入流：abstract InputStream\n典型实现：FileInputStream(file);\n①int read( ); //读取一个字节；返回读取的值，-1结束；\n②int read(byte[] b); //读入字节数组，返回读取字节数；\n③int read(byte[] b,int off,int len); \n//将字节读入数组某一部分；返回读取字节数；\n●void close()；//关闭流，并释放系统资源","expandState":"expand"},"children":[]},{"data":{"id":"bjm8ueqn55c8","created":1519565023562,"text":"2.字节输出流OutputStream","note":"字节输出流：abstract OutputStream\n典型实现：FileOutputStream(file,[append]);\n参数append=true，追加写append；\n①void write(int b); //写入一个字节\n②void write(byte[] b); //写入一个字节数组（byte[] 缓冲数组）\n③void write(byte[] b,int off,int len); //写入数组的某一部分\n●void flush()；//刷新缓冲，强制写出所有缓冲区数据；\n●void close()；//关闭流；\n\n读取文件时，必须要有文件；\n写入文件时，文件可以不存在；创建流对象时新建了文件；\n为什么要关闭close()；\nIO流操作是资源操作，必须关闭；\n①通知系统，该流对象变成垃圾；\n②通知垃圾回收期来回收垃圾，释放资源；","expandState":"expand"},"children":[]}]},{"data":{"id":"bjm8tccwo2ok","created":1519564940014,"text":"四、字符流","note":"字符流=字节流+字符集； 纯文本文档（.txt）；\n适用于操作多国语言（中文）的纯文本文档；\n●存在缓冲区关闭流之前，必须先flush()；","expandState":"expand"},"children":[{"data":{"id":"bjm8utd3l2go","created":1519565055395,"text":"1.字符输入流Reader","note":"字符输入流：abstract Reader；\n典型实现：转换流InputStreamReader(InputStream is)\nint read(); //读取单个字符；返回读取字符的int值，null结束\nint read(char[] c); //将字符读入数组；返回读取字符数；\nint read(char[] c,int off,int len); \n//将字符读入数组的某一部分；返回读取字符数；\nvoid close(); //关闭流，并释放系统资源","expandState":"expand"},"children":[]},{"data":{"id":"bjm8uwl4xwgk","created":1519565062412,"text":"2.字符输出流Writer","note":"字符输出流：Writer；\n典型实现：转换流OutputStreamWriter(OutputStream os)\n①void write(int c); //写入单个字符\n②void write(char[] b); //写入字符数组（char[] 缓冲数组）\n③void write(char[] b,int off,int len); //写入字符数组某一部分；\n●void flush()；//刷新缓冲，强制写出所有缓冲区数据；\n●void close()；//关闭流时，会自动执行flush()；\n\n字符流=字节流+字符集（编码和解码）；\n编码解码必须一致，否则中文乱码；\n字符输入转换流InputStreamReader\n字符输出转换流OutputStreamWriter\n将字节流通过字节流进行编码和解码，转换为字符流；","expandState":"expand"},"children":[]},{"data":{"id":"bjm8vb6bbhck","created":1519565094167,"text":"流文件","note":"流操作文件的一般步骤：\n①创建读的目标文件：File\n②创建输入流：InputStream\n③创建写的目标文件：File\n④创建输出流：OutputStream\n⑤创建缓冲数组：byte buf = new byte[1024]\n⑥while循环边读边写\nwhile((len = is.read()) != -1){\nos.write(buf,0,len) ; \n}\n⑦关闭流close( );\n\n\n字节流与字符流区别：\n（1）操作单位不同：\n字节流是按字节读写（文本图片音频视频）；\n字符流是按字符读写（纯文本文档）；\n（2）操作对象不同：\n字节流读写任意文件；\n字符流只能读写纯文本文档.txt；\n（3）使用不同：\n字节是文件的最小单元；原子级操作；\n字符是2个字节，组合时按照字符集编码进行；","expandState":"expand"},"children":[]}]},{"data":{"id":"bjm8tf9wmts8","created":1519564946363,"text":"五、缓冲流","expandState":"expand"},"children":[{"data":{"id":"bjm8w0c6o4gk","created":1519565148942,"text":"1.字节缓冲流","note":"①字节缓冲输入流：BufferedInputStream（被装饰对象）\n②字节缓冲输出流：BufferedOutputStream（被装饰对象）","expandState":"expand"},"children":[]},{"data":{"id":"bjm8w2ck9a80","created":1519565153318,"text":"2.字符缓冲流","note":"①字符缓冲输入流BufferedReader（被装饰对象）\nString readLine(); //读取一行字符（不包括换行符）；\n②字符缓冲输出流BufferedWriter（被装饰对象）\nvoid newLine(); //写入一个跨平台换行符；\n\n特点：自带一个默认缓冲区byte[8192]；\n使用缓冲输出流，必须强制刷新或者关闭；\n●void flush()；//刷新缓冲，强制写出所有缓冲区数据；\n●void close()；\n//存在缓冲区关闭流之前，必须先flush()；\n//关闭处理流时，只需关闭最外层即可（装饰设计模式）；","expandState":"expand"},"children":[]}]},{"data":{"id":"bjm8tiulz604","created":1519564954145,"text":"六、装饰设计模式（Decorator）","note":"装饰设计模式：对类进行功能扩展；\n①成员变量：被装饰对象\n②构造方法：装饰者要对被装饰对象初始化；\n③方法扩展：被装饰类的引用.被扩展的方法；\n④规范约束：抽象类，接口；\nIO中大量使用了装饰设计模式\n例如：缓冲流BufferedInputStream\n问题：继承代码扩展功能的弊端：\n1.增强了代码的耦合度\n2.单继承限制\n解决：装饰设计模式；","expandState":"expand"},"children":[]}]},{"data":{"id":"bjm8wqfwl008","created":1519565205763,"text":"其他处理流","note":"处理流：对节点流进行处理（缓冲流）；","expandState":"collapse"},"children":[{"data":{"id":"bjm8wvsjisws","created":1519565217411,"text":"一、缓冲流","note":"在使用处理流时，进行关闭操作时，只需关闭处理流即可；\n因为装饰设计模式中，外层","expandState":"expand"},"children":[]},{"data":{"id":"bjm8wzcmo7k8","created":1519565225156,"text":"二、转换流","expandState":"expand"},"children":[]},{"data":{"id":"bjm8x2l803s4","created":1519565232206,"text":"三、管道流","note":"作用：多用于线程间的通讯；\nPipedInputStream\nPipedOutputStream([pis])；可直接建立链接；\n建立管道链接：pos.connect(pis) ;\n（自带内部缓冲区）","expandState":"expand"},"children":[]},{"data":{"id":"bjm8xbkrs1kw","created":1519565251770,"text":"四、字节数组流","note":"作用：将字节数组转换成IO流\nByteArrayInputStream\nByteArrayOutputStream\n关闭无效\nsize()返回当前缓冲区的有效字节长度；","expandState":"expand"},"children":[]},{"data":{"id":"bjm8xhaqs88o","created":1519565264224,"text":"五、字符数组流","note":"作用：将字符数组转换成IO流\nCharArrayReader\nCharArrayWriter","expandState":"expand"},"children":[]},{"data":{"id":"bjm8xmcvvx4c","created":1519565275237,"text":"六、合并流","note":"作用：合并2个输入流\nSequenceInputStream(InputStream s1,InputStream s2)；\n只有合并输入流，没有合并输出流；","expandState":"expand"},"children":[]},{"data":{"id":"bjm8xrasrp4w","created":1519565285995,"text":"七、重定向流","note":"作用：重定向标准输入输出流\n1.标准输入输出流\nSystem.in从键盘输入\nSystem.out：输出到屏幕；\nSystem.err：输出到屏幕；\n2.System下的静态方法\nstatic void setIn(InputStream in);\nstatic void setOut(PrintStream ps);\nstatic void setErr(PrintStream ps);","expandState":"expand"},"children":[]},{"data":{"id":"bjm8xxex3484","created":1519565299305,"text":"八、随机访问文件流","note":"应用：断点下载，断点续传；\nRandomAccessFile\n1.参数mode：打开文件的访问模式\n“r”只读模式\n“rw”读写模式\n“rws”\n“rwd”\n2.存在指针，指向文件进行读写的位置；\ngetPointFile(); //获取当前指针的位置\n通过指针，按字节顺序读取；\n3.读取默认ISO-8859-1编码方式；需进行解码再重新编码；","expandState":"expand"},"children":[]},{"data":{"id":"bjm8y2npqko4","created":1519565310721,"text":"九、对象流","note":"应用：对象的持久化；\nObjectInputStream反序列化\nObjectOutputStream序列化\n对象流读写对象必须进行序列化Serializable；\n序列化：将一个对象转换成一串二进制的字节数组；\n反序列化：将字节数组重新构造成对象；\n序列化目的：为了对象传输，保证传输对象的一致性；\n如何序列化：使需要序列化的类实现Serializable","expandState":"expand"},"children":[]},{"data":{"id":"bjm8ya6lw7c4","created":1519565327101,"text":"十、数据流","note":"DataInputStream\nDataOutputStream","expandState":"expand"},"children":[]},{"data":{"id":"bjm8yemozzco","created":1519565336780,"text":"十一、打印流","note":"PrintStream\nprint(x); //只能有参输出；\nprintf(); //格式化输出；\nprintln(); //可无参输出；","expandState":"expand"},"children":[]}]},{"data":{"id":"bjm8yokd520c","created":1519565358407,"text":"NIO流","note":"NIO面向缓冲区的，基于通道的IO操作；（JDK1.4已产生）\n缓冲区（Buffer）：存储数据；\n通道（Channel）：传输数据；\nNIO与IO的区别：\nIO：基于流；阻塞式（每次只能操作一种流）；\nNIO：面向缓冲区，基于通道，选择器；非阻塞式；\nNIO将以更加高效的方式进行文件的读写操作；","expandState":"expand"},"children":[{"data":{"id":"bjm8yx0m1sg8","created":1519565376804,"text":"缓冲区（Buffer）","note":"缓冲区：一个用于特定基本类型数据的容器；\n缓冲区作用：保存数据；进行数据读写；\nBuffer常见实现：\nByteBuffer，ShortBuffer，IntBuffer，LongBuffer，\nFloatBuffer，DoubleBuffer，CharBuffer；无布尔型缓冲区。\n\n①建立缓冲区，分配容量：\nByteBuffer b = ByteBuffer.allocate(1024);\n清空缓冲区：Clear()\n②缓冲区属性\n位置：position()；\n限制：limit()；\n容量：capacity()；\n③读/写：get()；put()；\n④ 读写模式切换：filp();\n⑤标记：mark()；reset()；\n\n非直接缓冲区：allocate(capacity)；\n传输方式：拷贝方式；\n内存位置：位于堆区；\n特点：占用资源较少，容易被释放；But效率低；\n直接缓冲区：allocateDirect(capacity)；\n传输方式：内存映射；\n内存位置：直接位于内存页；\n特点：效率高；But分配资源消耗大，不易被回收；\n应用：一般分配给易受基础系统的本机IO操作的大型；","expandState":"expand"},"children":[]},{"data":{"id":"bjm8z37b7280","created":1519565390270,"text":"通道（Channel）","note":"通道作用：传输数据；\n1.Java 为 Channel 接口提供的最主要实现类如下：\n•FileChannel：用于读取、写入、映射和操作文件的通道。\n•DatagramChannel：通过 UDP 读写网络中的数据通道。\n•SocketChannel：通过 TCP 读写网络中的数据。\n•ServerSocketChannel：可以监听新进来的 TCP 连接，对每一个新进来的连接都会创建一个 SocketChannel。\n\n2.获取通道：\n本地IO：调用getChannel()；\nFileInputStream/FileOutPutStream \n\tRandomAccessFile\n网络IO：\nSocket\nServerSocket\nDatagramSocket\n获取通道的其他方式是：\nFiles类静态方法：newByteChannel() 获取字节通道（JDK1.7）\nChannel类静态方法：open(Path path,OpenOpertion ... oo)（JDK1.7）\n\n获取通道：\n①本地IO获取通道：本地IO.getChannel()；\n②打开通道FileChannle.open(Path path,OpenOpertion ... oo)\n\n使用通道进行数据传输：\n①使用通道+非直接缓冲区完成文件复制；\n②使用直接缓冲区完成文件复制（内存映射文件）\n③直接使用通道完成数据传输；\n\n分散读取和聚集写入\n①分散读取：read(ByteBuffer[] bufs)；\n②聚集写入：write(Bytebuffer buf1)；\nwhile((inChannel.read(bufs)) != -1) {\n\tfor(ByteBuffer b : bufs) {\n\t\tb.flip();\n\t\toutChannel.write(b);\n\t\tb.clear();\n\t}\n}\n\nNIO的非阻塞式网络通信：\n空闲通道：多路复用；\n网络通信的三要素：\n\t\tIP地址：可以唯一的定位到一台计算机\n\t\t端口号：可以唯一的定位到一个程序\n\t\t通信协议：TCP/IP  UDP\n\t阻塞式：\n\t\t客户端：\n\t\t\t1. 获取通道\n\t\t\t2. 分配指定大小的缓冲区\n\t\t\t3. 读取本地文件，并发送到服务端\n\t\t\t4. 关闭通道\n\t\t服务端：\n\t\t\t1. 获取通道\n\t\t\t2. 绑定连接\n\t\t\t3. 获取客户端连接的通道\n\t\t\t4. 分配指定大小的缓冲区\n\t\t\t5. 接收客户端的数据，并保存到本地\n\t\t\t6. 关闭通道\n\t非阻塞式：\n\t\t客户端\n\t\t\t1. 获取通道\n\t\t\t2. 切换非阻塞模式\n\t\t\t3. 分配指定大小的缓冲区\n\t\t\t4. 发送数据给服务端\n\t\t\t5. 关闭通道\n\t\t\t\n\t\t服务端\n\t\t  1. 获取通道\n\t\t\t2. 切换非阻塞模式\n\t\t\t3. 绑定连接\n\t\t\t4. 获取选择器\n\t\t\t5. 将通道注册到选择器上, 并且指定“监听接收事件”\n\t\t\t6. 轮询式的获取选择器上已经“准备就绪”的事件\n\t\t\t7. 获取当前选择器中所有注册的“选择键(已就绪的监听事件)”\n\t\t\t8. 获取准备“就绪”的是事件\n\t\t\t9. 判断具体是什么事件准备就绪\n\t\t\t10. 若“接收就绪”，获取客户端连接\n\t\t\t11. 切换非阻塞模式\n\t\t\t12. 将该通道注册到选择器上\n\t\t\t13. 获取当前选择器上“读就绪”状态的通道\n\t\t\t14. 读取数据\n\n选择器（Selector）\n作用：针对非阻塞式IO通信；\n打开选择器：Selector.open()；\n将通道注册到选择器：\nSelector.select()：查看选择器注册的通道数；\n键：SelectionKey，状态值\n值：Channel，通道","expandState":"expand"},"children":[]}]}]},{"data":{"id":"bjm4gzpybe0o","created":1519552687695,"text":"反射机制","expandState":"collapse"},"children":[{"data":{"id":"bjm8znpfvq8g","created":1519565434902,"text":"反射概述","note":"反射：在程序运行时，可以加载、探知、使用编译期完全未知的类；\n反射是Java被当作一门动态语言的基础；\n反射：在程序运行时，通过类的Class对象（类名、对象获取）去动态获取类构造器、属性、方法；使代码变的灵活；","expandState":"collapse"},"children":[{"data":{"id":"bjm8zsiu920c","created":1519565445386,"text":"类的加载","expandState":"expand"},"children":[{"data":{"id":"bjm8zvueu00k","created":1519565452616,"text":"类的加载","note":"①加载：将class文件加载到内存中；\n②链接：\na）验证：验证.class文件内部结构是否完整；确保不会危害虚拟机安全；\nb）准备：为static成员分配内存空间，赋默认值；\nc）解析：将符号引用解析为直接引用；\n③初始化：类的初始化；为静态成员赋值；","expandState":"expand"},"children":[]},{"data":{"id":"bjm903uzhegc","created":1519565470065,"text":"类的初始化时机","note":"①创建类的实例；\n②访问类的静态变量，或者为静态变量赋值；\n③调用类的静态方法；\n④使用反射方式来强制创建某个类或接口对应的Class对象；\n⑤初始化某个类的子类；\n⑥直接使用java.exe命令来运行某个主类；","expandState":"expand"},"children":[]},{"data":{"id":"bjm906tzes08","created":1519565476535,"text":"类加载器","note":"类加载器：将.class文件加载到内存中，为每一个类生成一个唯一的Class对象；\n①BootstapClassloader 根类加载器：JDK基本包（核心类库）\n②ExtensionClassloader 扩展类加载器：扩展类\n③ApplicationClassloader 应用/系统类加载器：classPath配置中的类；\n从上而下加载，从下而上检查； ","expandState":"expand"},"children":[]}]}]},{"data":{"id":"bjm91274jhcg","created":1519565544810,"text":"Class类","expandState":"collapse"},"children":[{"data":{"id":"bjm91ih8ocg0","created":1519565580250,"text":"获取Class对象","note":"①对象.getClass()；\n②类.class；\n③Class.forName(String className)；全类名；\n一个类只有唯一的一个Class对象；","expandState":"expand"},"children":[]},{"data":{"id":"bjm91lgq2bk0","created":1519565586749,"text":"获取类信息","note":"①public构造器：getConstructor(Class<?>... parameterTypes)；\n②public属性：getField()；\n③public方法：getMethod()；\n④private构造器：getDeclaredConstructor()；\n⑤private属性：getDeclaredField()；\n⑥private方法：getDeclaredMethod()；\nsetAccessible(true)；//true忽略访问权限；\n⑦获取该类的父类：getSuperclass()；\n⑧获取该类实现的接口：getInterfaces()；","expandState":"expand"},"children":[]},{"data":{"id":"bjm91p280dck","created":1519565594580,"text":"反射在实际开发中的应用","note":"主要应用于框架中；\nProperties类\nProperties类：解析.properties属性配置文件：\n.properties属性配置文件特点：\n①文件内容以键值对形式存在；\n②键和值以字符串形式存在；\n\nReturnObj","expandState":"expand"},"children":[]}]},{"data":{"id":"bjm915upukg0","created":1519565552767,"text":"工厂设计模式","expandState":"collapse"},"children":[{"data":{"id":"bjm926rsr808","created":1519565633131,"text":"简单工厂模式","note":"静态工厂模式；\n①具体工厂角色：创建产品对象\n②抽象产品角色：定义产品的标准和规范\n③具体产品角色：具体实现产品\n优点：创建对象不使用new，使用工厂创建；\n缺点：使工厂与产品产生了高度耦合，不符合类设计的开闭原则；","expandState":"expand"},"children":[]},{"data":{"id":"bjm92949rpc0","created":1519565638239,"text":"工厂方法模式","note":"①抽象工厂角色：\n②具体工厂角色：\n③抽象产品角色：\n④具体产品角色：\n优点：抽象工厂类的存在，降低了工厂与产品的耦合度；\n符合程序的开闭原则，程序扩展性更强；\n缺点：在扩展程序的时候，都需要创建具体工厂，程序较复杂；","expandState":"expand"},"children":[]},{"data":{"id":"bjm92bqno1cs","created":1519565643946,"text":"抽象工厂模式","note":"①抽象工厂角色：\n②具体工厂角色：\n③抽象产品角色：\n④具体产品角色：\n优点：分离接口与实现：客户端使用抽象工厂来创建需要的对象；\n切换产品族变的容易：\n缺点：不易扩展新产品：","expandState":"expand"},"children":[]}]},{"data":{"id":"bjm91a6fj34k","created":1519565562182,"text":"Array类","note":"Array类：动态创建和操作数组的类；\n使用反射操作数组：\n1.动态创建数组：Array.newInstance(类型.class,长度)；\n2.判断是否是数组：arr.getClass().isArray()；\n3.返回数组长度：Array.getLength(arr)；\n4.设置值：Array.setInt(arr, index, value);\n获取值：Array.getInt(arr, 0);\n5.返回数组组件的类型：Class<?> arrayType = arr.getClass().getComponentType();","expandState":"expand"},"children":[]},{"data":{"id":"bjm91cspdgws","created":1519565567883,"text":"代理模式","expandState":"expand"},"children":[{"data":{"id":"bjm92x1hvdc8","created":1519565690314,"text":"静态代理","note":"代理实现完全由程序员自己实现；只能针对特定的对象实现代理\n实现步骤：\n①定义主业务逻辑接口；\n②实现主业务接口；\n③代理类实现接口，增强主业务；\na）声明被代理对象：成员变量；\nb）绑定被代理对象：有参构造器；\nc）代理类增强主业务：方法扩展；","expandState":"expand"},"children":[]},{"data":{"id":"bjm92ztfvm88","created":1519565696357,"text":"动态代理","expandState":"expand"},"children":[{"data":{"id":"bjm936h1468k","created":1519565710844,"text":"JDK动态代理实现","note":"JDK动态代理实现\nInvocationHandler接口和proxy类；\nObject invoke(Object proxy, Method method, Object[] args)；\nproxy：代理对象\nmethod：扩展方法\nargs：扩展方法需要的参数\nstatic Object newProxyInstance(ClassLoader loader, Class<?>[] interfaces, InvocationHandler h) \nloader：被代理对象的类加载器；\ninterfaces：被代理类实现的接口；\nh：在代理类中所需要做的处理；被代理对象的处理器；\n代理对象必须实现接口，代理的是接口；\n实现步骤：\n①定义主业务逻辑接口；\n②实现主业务接口；\n③编写针对代理对象的处理方式； \nimplements InvocationHandler，实现invoke()；\n使用步骤：\n①创建代理对象实例\n②创建代理的处理器对象并绑定被代理对象；\n③创建代理对象（被代理对象的接口）\nproxy.newProxyInstance()，返回值是接口对象；\n④通过代理对象调用主业务逻辑；","expandState":"expand"},"children":[]},{"data":{"id":"bjm93ct9ws0s","created":1519565724646,"text":"cglib动态代理实现","note":"cglib动态代理实现\n优点：代理类不需要实现接口；运行速度快；\n实现步骤：\n①实现主业务逻辑\n②代理类implements MethodInterceptor\n增强器：Enhancer；\n实现interceptor方法\nmethodProxy.invokeSuper(被代理对象，方法参数)；\n使用步骤：\n①生成代理对象；\n②代理对象调用方法；","expandState":"expand"},"children":[]}]}]}]},{"data":{"id":"bjm4h7qe5pck","created":1519552705136,"text":"多线程","expandState":"collapse"},"children":[{"data":{"id":"bjm94477eego","created":1519565784261,"text":"多线程概述","note":"进程：一个正在运行的程序；在计算机中的运行路径；\n一个程序只能有一个进程；\n程序是静态的，进程是动态的；\n线程：进程的组成单元，在一个进程中有一个或多个线程；\n并发：多个任务轮询交替执行；\n并行：多任务同时执行；\nCPU调度方式：\n①时间片轮询；\n②抢占式调度方式； Java采用抢占式；\n进程与线程共享“堆内存和方法区”；一个线程一个“栈内存”；\n \nJava程序的运行原理：\n当使用Java命令启动一个程序的时候，JVM启动，就启动了一个进程；main方法会执行，main方法就是该进程中的一个线程（主线程），同时也会启动GC是后台线程（守护线程）；","expandState":"expand"},"children":[]},{"data":{"id":"bjm946nqxy0c","created":1519565789615,"text":"创建线程","note":"1.创建线程\n①继承Thread类；\n②实现Runnable接口：本质是Thread(Runnable target)；\n核心步骤：重写run方法，写入该线程要完成的事情；\n2.使用步骤：\t\na）重写run方法；\nb）创建线程对象；\nc）调用start()；\n3.两种线程实现方式的区别：\n继承Thread类\t实现Runnable接口\n优点：\t可直接使用线程所有方法；\t多实现；\n缺点：\t单继承；\t不能直接创建线程；","expandState":"expand"},"children":[]},{"data":{"id":"bjm948v2yjkk","created":1519565794412,"text":"线程控制","note":"1.线程名称\n①设置名称：\nThread(String name)；\nsetName(String name)；\n②String getName()；\n③long getId()；//线程终生不变的唯一的标识符；\n系统会为创建的线程设置默认Name：Thread-01；\n主线程默认Name：main；\n2.获取当前执行线程\nThread.currentThread()；返回对当前正在执行的线程对象的引用；\n3.线程休眠\nThread.sleep(long millis)；在指定的毫秒数内让当前正在执行的线程休眠（暂停执行）；\n4.守护线程\nvoid setDaemon(true)；将线程标记为守护线程；\nisAlive()；判断线程是否是活动状态（已启动未终止）；\nisDaemon()；判断线程是否是守护线程；\n5.加入线程\nvoid join()；当前线程暂停执行，直到加入的线程执行完毕；\n应用：可以让另一个线程优先执行；\n\n6.礼让线程\nThread.yield()；暂停当前正在执行的线程对象，其他线程并不一定能抢占到。\n7.线程优先级\nJava抢占式线程调度算法；优先级1-10；默认优先级5；\ngetPriority()；返回线程的优先级。\nsetPriority(int newPriority)；更改线程的优先级。\n\n线程异常只能处理，不能抛出，无接受异常者；","expandState":"expand"},"children":[]},{"data":{"id":"bjm94ayazyg4","created":1519565798960,"text":"线程的生命周期","note":"线程状态\n1.新建（New）：创建线程对象（new）；JVM为其分配内存，并初始化其成员变量的值\n2.就绪（Runnable）：线程对象调用start()；JVM为其创建方法调用栈和程序计数器，等待CPU调度运行；\n3.运行（Running）：线程获得CPU使用权，开始执行run()；\n4.阻塞（Blocked）：当前正在执行的线程由于某种原因（休眠，礼让，时间到达）暂时失去CPU使用权，等待再次获得CPU使用权；\n线程进入阻塞状态：\n①wait()；\n②执行同步锁时，锁对象被其他线程占用；\n③IO操作；\n④sleep()，join()；\n解除阻塞：\n\n5.死亡（Dead）：线程执行结束；isAlive()==false；\n①run()或call()方法执行完成，线程正常结束。\n②线程抛出一个未捕获的Exception或Error。\n③直接调用该线程stop()方法来结束该线程——该方法容易导致死锁，通常不推荐使用。","image":"http://kityminder-img.gz.bcebos.com/9bb0e4366ebb474c49c8c218d9a34bb97884b97a","imageTitle":"","imageSize":{"width":200,"height":65},"expandState":"expand"},"children":[]},{"data":{"id":"bjm94d8rbe8s","created":1519565803946,"text":"线程同步","note":"线程同步：保护共享数据，防止数据不一致；\n①同步代码块：\nsynchronized(obj){\n}\n锁对象：可任意对象；但要保证多线程使用同一锁对象，实现多线程同步；\n不能在run()中的同步代码块中使用this作为锁对象；\n②同步方法：\n同步方法：synchronized关键字修饰的方法；\n普通方法锁对象：this；\n静态方法锁对象：本类Class对象；","expandState":"collapse"},"children":[{"data":{"id":"bjm98dw27h4c","created":1519566118812,"text":"多线程环境中安全使用集合API","note":"Collections.synchronizedXxxx()；\nCollections中的静态synchronized方法：\n①Collection synchronizedCollention(Collection c)；\n②List synchronizedList(list l)；\n③Set synchronizedSet(Set s)；\n④Map synchronizedMap(Map m)；\n// Synchronized集合是线程安全的，但Iterator不是线程安全的；\nList list = Collections.synchronizedList(new ArrayList());\n   ...\n//迭代时，阻塞其他线程调用add()或remove()修改元素；\nsynchronized(list) {\n    Iterator i = list.iterator(); // Must be in synchronized block\n      while (i.hasNext())\n          foo(i.next());\n  }","expandState":"expand"},"children":[]}]},{"data":{"id":"bjm94gcdvfkk","created":1519565810696,"text":"定时任务","note":"Timer类\nTimerTask：实现 Runnable接口，重写run()方法；由 Timer 安排为一次执行或重复执行的任务。 \nvoid schedule(TimerTask task, Date firstTime, long period)；\n*task 执行的任务\n*firsttime 开始执行的时间\n*period 任务的间隔执行时间","expandState":"expand"},"children":[]},{"data":{"id":"bjm94j56yps0","created":1519565816791,"text":"Java并发编程Executor框架与线程池","note":"Executor框架：基于并发编程的线程池；","expandState":"collapse"},"children":[{"data":{"id":"bjm954gwun4k","created":1519565863212,"text":"创建线程池","note":"创建线程池\nExecutors的静态方法：\n①创建一个固定线程数的线程池：\nstatic ExecutorService Executors.newFixedThreadPool(int nThreads)；\n线程池中，如果有空闲线程，则执行任务；如果没有空闲线程，则任务进入阻塞状态，等待空闲线程；\n线程池执行任务：void execute(Runnable command)；\n②创建一个带有缓存的线程池\nstatic ExecutorService newCachedThreadPool() ；\n线程池中，如果有空闲线程，则执行任务；如果没有空闲线程，则创建一个新线程执行任务；\n ③创建一个单线程线程池\nstatic ExecutorService newSingleThreadExecutor()；\n线程池中，如果有空闲线程，则执行任务；如果没有空闲线程，则创建一个新线程执行任务；\n④创建一个定时执行线程池\nstatic ScheduledExecutorService newScheduledThreadPool(int corePoolSize) \n类似FixedThreadPool；\n定时执行方法：\nScheduledFuture<?> schedule(Runnable command, long delay, TimeUnit unit)；\n*command - 要执行的任务\n*delay - 从现在开始延迟执行的时间\n*unit - 延迟参数的时间单位 \n\n一般情况下，生命周期短的CachedThreadPool是首选；但是在特殊情况下（线程数>系统负载），生命周期长的会选择FixedThreadPool；","expandState":"expand"},"children":[]},{"data":{"id":"bjm957h7b0w8","created":1519565869760,"text":"线程池可执行的任务","note":"线程池可执行的任务：\nRannable接口：public void run()；//无返回值；\nCallable<v>接口：public V call()； //有返回值；\n\nsubmit()；\nget()；\n\n线程池的生命周期\n运行状态：\n关闭状态：shutdown()；任务提交，不在执行新任务；\n终止状态：任务全部提交完毕","expandState":"expand"},"children":[]}]},{"data":{"id":"bjm94l8rpoo4","created":1519565821361,"text":"线程协作","note":"多个线程同时完成一个任务时，多个线程共享任务数据；防止数据不一致，使用线程同步（synchronized）机制；\nsynchronized：\n原子性：在每次执行任务时，能保证只有一个线程在执行任务；\n可见性：针对每一个线程执行任务时，所见到的数据都真是有效；\n1.用5个售票窗口销售100张火车票；\n2.银行账户有1000元，一个人去柜台取钱，另一个人去ATM机取钱；\n取款方式：柜台，ATM机；\n银行类，一个账户，两个线程模拟取钱，\n3.火车过山洞：\n火车由A到B，中间有一个隧道，每次只允许一趟火车通过，每趟火车经过隧道需要10s，为防止事故发生，每次只允许一趟火车经过，现有5趟火车经过隧道；","expandState":"expand"},"children":[]},{"data":{"id":"bjm94nggo288","created":1519565826180,"text":"线程死锁","note":"多个线程争取锁对象的持有权时的竞争现象；\n避免死锁：\n①尽量避免锁的嵌套使用；\n②让程序执行时，尽可能只获得一个锁；\n③超时限制：Lock中的tryLock，在获取锁对象时，可设置时间限制；","expandState":"expand"},"children":[]},{"data":{"id":"bjm94rcvju0o","created":1519565834670,"text":"线程通信","expandState":"expand"},"children":[{"data":{"id":"bjm94voek9sg","created":1519565844074,"text":"Object类的监视器方法（monitor）","note":"Object类的监视器方法（monitor）\n等待/通知机制\nObject监视器方法：wait()、notify()、notifyAll()；\nwait()：使线程进入等待状态，如果没有线程来唤醒，则一直处于等待状态；\nwait(long timeout)：使线程进入等待状态； \nnotify()：唤醒当前处于等待状态的随机一个线程；\nnotifyAll()：唤醒当前处于等待状态的所有线程；\n锁对象执行wait()；和notify()；","expandState":"expand"},"children":[]},{"data":{"id":"bjm94y9vv8gg","created":1519565849726,"text":"互斥锁（Lock接口）","note":"互斥锁（Lock接口）\n互斥锁：在一次执行中只能有一个线程持有锁对象；（JDK5新特性）\nLock接口+Condition接口；\n2个以上线程通信，用到互斥锁；","expandState":"expand"},"children":[]},{"data":{"id":"bjm9508urgo4","created":1519565854018,"text":"生产者-消费者模型","note":"生产者-消费者模型\n基于等待/通知机制；\n①仓库：共享数据\n②生产者：线程同步；不满足条件，wait；满足条件，生产产品+notify；\n③消费者：线程同步；不满足条件，wait；满足条件，消费产品+notify；","expandState":"expand"},"children":[]}]}]},{"data":{"id":"bjm4har3h748","created":1519552711709,"text":"GUI","expandState":"collapse"},"children":[{"data":{"id":"bjm9a7988288","created":1519566261099,"text":"容器Container","expandState":"expand"},"children":[{"data":{"id":"bjm9atlae6o8","created":1519566309717,"text":"窗体Frame","note":"顶级容器：可独立存在；Frame\nJDialog","expandState":"expand"},"children":[]},{"data":{"id":"bjm9avtsoy88","created":1519566314585,"text":"面板Panel","note":"中间容器：依赖于其他容器存在，不能单独存在；Panel\nPanel被Frame添加add","expandState":"expand"},"children":[]}]},{"data":{"id":"bjm9acqygjcw","created":1519566273055,"text":"容器布局管理器LayoutManager","note":"LayoutManager：组件在面板上的排列方式；\n流式布局：FlowLayout，按添加顺序从左向右放置；默认；\n边框布局：BorderLayout，将容器划分为东、南、西、北、中；\n网格布局：GridLayout(rows,cols)，划分为rows行cols列大小相等的网格；\n卡片布局：CardLayout，只有一张卡片可见，切换卡片，切换功能；\n空布局：setLayout(null)；通过坐标setBounds()，自定义组件位置；","expandState":"expand"},"children":[]},{"data":{"id":"bjm9afrihw08","created":1519566279619,"text":"组件Component","expandState":"expand"},"children":[{"data":{"id":"bjm9b9e6ymg4","created":1519566344117,"text":"文本JTextField","expandState":"expand"},"children":[]},{"data":{"id":"bjm9bc5z7gg0","created":1519566350150,"text":"菜单栏Menu","note":"菜单条MenuBar-->菜单Menu-->菜单项MenuItem","expandState":"expand"},"children":[]},{"data":{"id":"bjm9bemo4rkg","created":1519566355513,"text":"表格JTable","note":"JTable=columnNames+cellDate；\nJTable，TableModel，TableColumn；\n①JTable的表头其实也是一个单独的组件TableHeader\n②每一列也可以被划分出来作为一个组件TableColumn；\n\n1.创建表格：\n①JTable table = new JTable([rows],[cols])；\n②以表头和单元格数据创建表格\nJTable table = new JTable(Object[][] cellData , String[] columnNames)；\nJTable(Vector rowData, Vector columnNames)；\n③通过表格模板创建表格\nDefaultTableModel model = DefaultTableModel(Object[][] data, Object[] columnNames)；\nJTable table = new JTable(model);\n重写isCellEditable()使表格不可编辑\npublic boolean isCellEidtable() {\n\t\treturn false;\n}\n2.显示表头：\n①添加到滚动面板：panel.add(new JScrollPane(table))；//常用\n②获取表头方法：panel.add(table.getTableHeader(),BorderLayout.NORTH)\n3.行控制\n①行高：table.setRowHeight(20);\n②设置行数：tableModel.setRowCount(n);\n③获取行数：int rows = table.getRowCount();\n④添加表格行\ntableModel.addRow(new Object[]{\"sitinspring\", \"35\", \"Boss\"});\n⑤删除表格行\nmodel.removeRow(rowIndex); //行序号\n4.列控制\n① 设置列不可随容器组件大小变化自动调整宽度.\ntable.setAutoResizeMode(JTable.AUTO_RESIZE_OFF);\n②限制某列的宽度.\nTableColumn firstColumn = table.getColumnModel().getColumn(0);\nfirstColumn.setPreferredWidth(30);\nfirstColumn.setMaxWidth(30);\nfirstColumn.setMinWidth(30);\n③设置当前列数.\ntableModel.setColumnCount(5);\n④取得表格列数\nint cols = table.getColumnCount();\n⑤添加列\ntableModel.addColumn(\"新列名\");\n⑥删除列\ntable.removeColumn(table.getColumnModel().getColumn(columnIndex)); //列序号\n\n5.表格控制\n①获取单元格数据\nString cellValue=(String) tableModel.getValueAt(row, column);\n②获取TableModel：table.getModel();\n③添加tableModel.addRow(arr)；","expandState":"expand"},"children":[]}]},{"data":{"id":"bjm9aj0b0c8w","created":1519566286681,"text":"事件处理机制","note":"1.事件源（组件）+事件监听器（XXXXListener）;\n2.注册事件监听器（addXXXXListener）;\nActionnListener，MouseListener，KeyListener；\nWindowListener，MouseMotionListener；\n3.事件处理：在监听器接口中的动作方法中处理事件；\n在swing事件处理机制中采用的设计模式：适配器模式；","expandState":"expand"},"children":[]},{"data":{"id":"bjm9algiy0ow","created":1519566292015,"text":"适配器模式","note":"有些情况下，无需实现接口所有方法，只需根据需求，实现部分方法即可；\n①定义一个接口，在接口中定义规范；\n②定义一个抽象类（适配器），抽象类实现接口，空实现接口方法；\n③无需实现接口（无需实现所有方法），只需继承适配器（重写部分方法）；","expandState":"expand"},"children":[]},{"data":{"id":"bjm9anwrbrk8","created":1519566297350,"text":"JavaGUI的实现","note":"1.窗体JFrame的创建和设置；\n2.面板JPanel的创建和设置；\n3.组件的创建和设置；\n4.组件组装：frame.add(panel)；panel.add(组件)；\n5.显示窗体：frame.setVisiable(true)；\n6.事件处理机制：\n①事件源：组件\n②注册事件监听器：addXXXXListener( )；\n③事件处理：动作方法的实现；","expandState":"expand"},"children":[]}]},{"data":{"id":"bjm4hdz5ns8o","created":1519552718727,"text":"网络编程","expandState":"collapse","note":"IP：唯一的定位到网络中的一台计算机；\nTCP：面向连接，保证数据的可靠传输；\nUDP：面向无连接，不可靠的；\n使用UDP数据报：TFTP，SNMP，DNS，NFS网络文件系统\nIPv4：32位，4段*8位；\n域名：一个IP地址对应一个域名，映射关系；\nHTTP协议：超文本传输协议;\n发送HTTP请求的请求方式：GET，POST，PUT，DELETE；\nURL：统一资源定位符；\n常用网络命令：\n①Ipconfig，\n    ②ping：检测计算机之间的连通性；"},"children":[{"data":{"id":"bjm9cmdr4aw4","created":1519566450752,"text":"IP地址类：InetAddress","note":"获取InetAddress对象：\n①InetAddress[] getAllByName(String host)； \n②InetAddress getByAddress(byte[] addr)；\n③InetAddress getByAddress( [String host] , byte[] addr )； \n④InetAddress getByName(String host)；\n⑤InetAddress getLocalHost()；//返回本地主机；\n常用方法：\n//获取本机名称\nip.getHostName();\n//获取本机地址\nip.getHostAddress();","expandState":"expand"},"children":[]},{"data":{"id":"bjm9cp55mt4w","created":1519566456763,"text":"URL","note":"URL：统一资源定位符；互联网资源指针；\n1.URL\n\n2.URLConnection\nopenConnection()；\n\n3.URL编码与解码\nURLEncoder：编码\nURLDecoder：解码","expandState":"expand"},"children":[]},{"data":{"id":"bjm9crkxfk84","created":1519566462070,"text":"Socket编程","expandState":"expand"},"children":[{"data":{"id":"bjm9d2y5au8k","created":1519566486814,"text":"基于TCP的Socket编程","note":"TCP：面向连接的，可靠传输；\n每进行一次客户端-服务端任务，建立一次连接；\n1.客户端：\n①Socket client = new Socket(服务端IP地址, 端口号); \n②获取client的IO流；\n③进行数据传输write&read；\n④释放资源close()；\n2.服务端：\n①ServerSocket server = new ServerSocket(端口号);\nSocket socket = server.accept(); //客户端的一次请求\n②获取socket的IO流；\n③数据传输read&write；\n④释放资源close()；\n3.优化：\n①IO流：BufferedReader的readLine()；PrintWriter的write(String str)；\n②多线程/线程池处理Server高并发","expandState":"expand"},"children":[]},{"data":{"id":"bjm9d5928204","created":1519566491827,"text":"基于UDP的Socket编程","note":"UDP：面向无连接，不可靠传输；\n发送端与接受端是相对的，不是绝对的；\n1.发送端（sender）\n①DatagramSocket sender = new DatagramSocket();\n②创建一个发送数据报包（DatagramPacket）：\nDatagramPacket(byte[] buf, int offset, int length, 目的IP地址, 端口号) ; \n③发送数据报包sender.send(发送数据报);\n2.接收端（receiver）\n①DatagramSocket sender = new DatagramSocket(端口号);\n②创建一个接收数据报包（DatagramPacket）：\nDatagramPacket(byte[] buf, int offset, int length); \n③接收数据报包receiver.receive(接受数据报);","expandState":"expand"},"children":[]}]}]},{"data":{"id":"bjm4hh3w9zk8","created":1519552725544,"text":"JUnit单元测试框架","expandState":"collapse","note":"JUnit单元测试框架，第三方框架，XUnit中的一员；\nJUnit3与JUnit4编写区别：\n①JUnit3中的测试方法，必须以testXXX()命名；\n②JUnit4中取消了以test前缀命名的规则，可任意命名；\n单元测试优点：\n①测试不需要去编写main()；\n②可以针对不同的类，建立不同的单元测试类；\n③可以针对不同方法，建立不同的单元测试方法； "},"children":[{"data":{"id":"bjm9dr5tsvco","created":1519566539521,"text":"JUnit的使用","note":"1.@Test基本测试用例\n2.断言测试\n断言：判断预期结果与实际结果的差异；\nAssert.assertEquals(预测结果,实际结果);\n3.JUnit基本常用注解\n@Before：方法在每个测试方法执行之前执行Before方法；\n@After：方法在每个测试方法执行之后执行After方法；\n@BeforeClass：static方法在测试类初始化时执行，只执行一次；\n@AfterClass：static方法在测试类结束时执行，只执行一次；\n@Test(timeout 1000)：设置方法执行超时时限；\n@Test(expected= XX.class)：方法执行的期望结果；\n@RunWith：用在类上，表明当前测试环境；\n4.JUnit套件测试\n@RunWith(Suite.class)\n@Suite.SuiteClasses({\n\tTestDemo.class,\n\tTest1.class,\n\tTest2.class,\n\tTest3.class,\n\tTest4.class\n})\n5.JUnit参数化测试","expandState":"expand"},"children":[]}]},{"data":{"id":"bjm9e1p6g0g8","created":1519566562459,"text":"GC&JVM","expandState":"collapse"},"children":[{"data":{"id":"bjm9e531yyw4","created":1519566569828,"text":"栈","note":"本地方法接口：native；\n栈：主要用来执行java程序，线程私有，生命周期与线程相同，\n本地方法栈：为执行本地方法分配内存空间；\n程序计数器：标记程序执行的跳转和调用；实现选择/循环\n每一个线程都拥有独立的栈、本地方法栈、PC；\nStackOverflowError：方法不断入栈，栈溢出\n（例：方法自己调用自己，没有递归结束条件；）","expandState":"expand"},"children":[]},{"data":{"id":"bjm9eas4hs00","created":1519566582228,"text":"方法区","expandState":"expand"},"children":[]},{"data":{"id":"bjm9ed1zpf4s","created":1519566587178,"text":"堆内存","note":"堆内存：新生代（Eden，from，to），老年代，永久代（不属于堆区）；\nEden-->Survive0（from）-->Survive1（to）-->老年代；\nJava1.8之后，将 永久代 更改为 元空间；\nOutOfMemoryError：内存溢出；\n①JVM堆内存大小设置不够，更改参数可改变内存大小\n②\nMaxMemory占1/4，total_Memory占1/64；","expandState":"expand"},"children":[]}]}]}]},"template":"right","theme":"fresh-blue","version":"1.4.43"}